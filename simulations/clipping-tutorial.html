<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Edge Clipping Tutorial</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=DM+Sans:wght@300;500;700&display=swap');

    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0
    }

    :root {
      --bg: #0b0d12;
      --panel: #12151d;
      --border: #1d2130;
      --green: #3ddc84;
      --orange: #ff8c42;
      --blue: #4da6ff;
      --purple: #b48eff;
      --red: #ff4d6d;
      --yellow: #ffd166;
      --text: #dde3f0;
      --muted: #5a6480;
      --accent: #4da6ff;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'DM Sans', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 12px 14px;
      gap: 10px
    }

    h1 {
      font-size: 1.15rem;
      font-weight: 700;
      color: var(--accent);
      letter-spacing: -.02em;
      text-align: center
    }

    /* TOP CONTROLS â€” always at top */
    #top-bar {
      display: flex;
      gap: 9px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      max-width: 980px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 14px;
    }

    button {
      background: #181d2a;
      border: 1px solid var(--border);
      color: var(--text);
      font-family: 'DM Sans', sans-serif;
      font-size: .85rem;
      font-weight: 600;
      padding: 8px 18px;
      border-radius: 8px;
      cursor: pointer;
      transition: all .15s
    }

    button:hover {
      background: #1e2438;
      border-color: var(--accent)
    }

    #btn-next {
      background: var(--accent);
      color: #0b0d12;
      border-color: var(--accent);
      font-size: .9rem;
      padding: 9px 22px
    }

    #btn-next:hover {
      background: #6dbeff
    }

    #btn-restart {
      color: var(--red);
      border-color: var(--red)
    }

    #btn-tts {
      color: var(--yellow);
      border-color: var(--yellow);
      font-size: .8rem;
      padding: 7px 14px
    }

    #btn-tts.off {
      color: var(--muted);
      border-color: var(--border)
    }

    #prog {
      font-family: 'JetBrains Mono', monospace;
      font-size: .72rem;
      color: var(--muted);
      margin-left: 4px
    }

    /* MAIN AREA */
    #main {
      display: flex;
      gap: 12px;
      width: 100%;
      max-width: 980px;
      align-items: flex-start;
      flex-wrap: wrap
    }

    #canvas-wrap {
      flex: 1 1 580px;
      position: relative
    }

    canvas {
      width: 100%;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      display: block;
      cursor: default
    }

    canvas.drag {
      cursor: grabbing
    }

    /* INFO BOX */
    #info {
      width: 100%;
      max-width: 980px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 13px 18px;
      min-height: 80px
    }

    #step-title {
      font-size: .95rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 4px
    }

    #step-desc {
      font-family: 'JetBrains Mono', monospace;
      font-size: .78rem;
      line-height: 1.8;
      color: var(--text)
    }

    /* BOTTOM CONTROLS (sliders) */
    #bottom-controls {
      width: 100%;
      max-width: 980px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden
    }

    #ctrl-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-size: .8rem;
      font-weight: 600;
      color: var(--muted);
      user-select: none;
      border-bottom: 1px solid transparent;
      transition: border-color .2s
    }

    #ctrl-toggle:hover {
      color: var(--text)
    }

    #ctrl-toggle.open {
      border-bottom-color: var(--border);
      color: var(--text)
    }

    #ctrl-body {
      display: none;
      padding: 14px 16px
    }

    #ctrl-body.open {
      display: flex;
      gap: 20px;
      flex-wrap: wrap
    }

    .ctrl-group {
      flex: 1 1 200px
    }

    .ctrl-group h4 {
      font-size: .68rem;
      font-weight: 700;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .09em;
      margin-bottom: 10px
    }

    .srow {
      margin-bottom: 7px
    }

    .srow label {
      font-size: .7rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px
    }

    .srow label span {
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent)
    }

    .srow input[type=range] {
      width: 100%;
      accent-color: var(--accent)
    }

    .legend {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      font-size: .7rem;
      color: var(--muted);
      width: 100%;
      max-width: 980px
    }

    .legend span {
      display: flex;
      align-items: center;
      gap: 4px
    }

    .legend span::before {
      content: '';
      display: inline-block;
      width: 16px;
      height: 3px;
      border-radius: 2px
    }

    .lr::before {
      background: var(--green)
    }

    .li::before {
      background: var(--orange)
    }

    .lt::before {
      background: var(--blue)
    }

    .lp::before {
      background: var(--purple)
    }

    .lc::before {
      background: var(--red)
    }

    .lf::before {
      background: var(--yellow)
    }
  </style>
</head>

<body>

  <h1>Edge Clipping â€” Interactive Visual Tutorial</h1>

  <!-- TOP: next/prev always visible -->
  <div class="toolbar"
    style="width:100%;max-width:980px;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px 14px;display:flex;justify-content:space-between;align-items:center;">
    <div class="toolbar-group" style="display:flex;align-items:center;gap:12px;">
      <div class="ctrl" style="display:flex;gap:8px;">
        <button id="btnPrev" disabled
          style="background:#181d2a;border:1px solid var(--border);color:var(--text);font-family:'DM Sans',sans-serif;font-size:.85rem;font-weight:600;padding:8px 18px;border-radius:8px;cursor:pointer;">â†
          Prev</button>
        <button id="btnNext" class="primary"
          style="background:var(--accent);color:#0b0d12;border:1px solid var(--accent);font-family:'DM Sans',sans-serif;font-size:.85rem;font-weight:600;padding:8px 18px;border-radius:8px;cursor:pointer;">Next
          â†’</button>
        <button id="btnAuto"
          style="background:#181d2a;border:1px solid var(--border);color:var(--text);font-family:'DM Sans',sans-serif;font-size:.85rem;font-weight:600;padding:8px 18px;border-radius:8px;cursor:pointer;">â–¶
          Auto</button>
        <button id="btnReset"
          style="background:#181d2a;border:1px solid var(--red);color:var(--red);font-family:'DM Sans',sans-serif;font-size:.85rem;font-weight:600;padding:8px 18px;border-radius:8px;cursor:pointer;">â†º</button>
        <button id="btnMute" title="Toggle narration"
          style="background:#181d2a;border:1px solid var(--yellow);color:var(--yellow);font-family:'DM Sans',sans-serif;font-size:.85rem;font-weight:600;padding:8px 18px;border-radius:8px;cursor:pointer;">ğŸ”Š</button>
        <button id="btnMuteMusic" title="Toggle music"
          style="background:#181d2a;border:1px solid var(--border);color:var(--text);font-family:'DM Sans',sans-serif;font-size:.85rem;font-weight:600;padding:8px 18px;border-radius:8px;cursor:pointer;">ğŸµ</button>
      </div>
      <div id="prog" style="font-family:'JetBrains Mono',monospace;font-size:.72rem;color:var(--muted);">Step 1 of â€”
      </div>
    </div>
  </div>

  <!-- CANVAS -->
  <div id="main">
    <div id="canvas-wrap">
      <canvas id="c" width="700" height="460"></canvas>
    </div>
  </div>

  <!-- INFO -->
  <div id="info">
    <div id="step-title">Ready to Start</div>
    <div id="step-desc">Drag the <b style="color:#3ddc84">green</b> or <b style="color:#ff8c42">orange</b> vertices on
      the canvas to reposition them, then press <b>Next Step</b> to begin the tutorial. Or expand <b>Edge Controls</b>
      below.</div>
  </div>

  <!-- LEGEND -->
  <div class="legend">
    <span class="lr">Reference Edge</span>
    <span class="li">Incident Edge</span>
    <span class="lt">Tangent</span>
    <span class="lp">Projection</span>
    <span class="lc">Clip Point</span>
    <span class="lf">Final Output</span>
  </div>

  <!-- BOTTOM COLLAPSIBLE SLIDERS -->
  <div id="bottom-controls">
    <div id="ctrl-toggle">â–¶ Edge Controls (expand to adjust positions)</div>
    <div id="ctrl-body">
      <div class="ctrl-group">
        <h4>â— Reference Edge</h4>
        <div class="srow"><label>Ref Vertex 1 â€” X <span id="rv1x-v">143</span></label><input type="range" id="rv1x"
            min="20" max="680" value="143"></div>
        <div class="srow"><label>Ref Vertex 1 â€” Y <span id="rv1y-v">222</span></label><input type="range" id="rv1y"
            min="20" max="440" value="222"></div>
        <div class="srow"><label>Ref Vertex 2 â€” X <span id="rv2x-v">560</span></label><input type="range" id="rv2x"
            min="20" max="680" value="560"></div>
        <div class="srow"><label>Ref Vertex 2 â€” Y <span id="rv2y-v">224</span></label><input type="range" id="rv2y"
            min="20" max="440" value="224"></div>
      </div>
      <div class="ctrl-group">
        <h4>â— Incident Edge</h4>
        <div class="srow"><label>Inc Vertex 1 â€” X <span id="iv1x-v">607</span></label><input type="range" id="iv1x"
            min="20" max="680" value="607"></div>
        <div class="srow"><label>Inc Vertex 1 â€” Y <span id="iv1y-v">84</span></label><input type="range" id="iv1y"
            min="20" max="440" value="84"></div>
        <div class="srow"><label>Inc Vertex 2 â€” X <span id="iv2x-v">70</span></label><input type="range" id="iv2x"
            min="20" max="680" value="70"></div>
        <div class="srow"><label>Inc Vertex 2 â€” Y <span id="iv2y-v">365</span></label><input type="range" id="iv2y"
            min="20" max="440" value="365"></div>
      </div>
    </div>
  </div>

  <script>
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // CANVAS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const CV = document.getElementById('c');
    const cx = CV.getContext('2d');
    const W = 700, H = 460;
    CV.width = W; CV.height = H;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // VECTOR MATH
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const vm = {
      sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
      add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
      sc: (a, t) => ({ x: a.x * t, y: a.y * t }),
      dot: (a, b) => a.x * b.x + a.y * b.y,
      len: (a) => Math.sqrt(a.x * a.x + a.y * a.y),
      norm: (a) => { const l = Math.sqrt(a.x * a.x + a.y * a.y) || 1; return { x: a.x / l, y: a.y / l }; },
      perp: (a) => ({ x: -a.y, y: a.x }),  // 90Â° CCW
      proj: (pt, anc, t) => { const d = vm.dot(vm.sub(pt, anc), t); return vm.add(anc, vm.sc(t, d)); },
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // GEOMETRY â€” recomputed live
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let G = {};

    function computeGeo() {
      const g = id => +document.getElementById(id).value;
      const refV1 = { x: g('rv1x'), y: g('rv1y') };
      const refV2 = { x: g('rv2x'), y: g('rv2y') };
      const incV1 = { x: g('iv1x'), y: g('iv1y') };
      const incV2 = { x: g('iv2x'), y: g('iv2y') };

      const tang = vm.norm(vm.sub(refV2, refV1));
      const negT = vm.sc(tang, -1);
      // refNormal points "inward" (downward for horizontal ref edge = positive Y in canvas coords)
      // For a horizontal edge going leftâ†’right, the inward normal points down: perp of tang CLOCKWISE = (tang.y, -tang.x)... incorrect per user request.
      // USER REQUEST: visual was opposite. Let's make normal point DOWN (perp CCW = -y, x).
      // tang=(1,0) -> perp=(-0, 1) = (0,1). This is DOWN.
      const refNormal = vm.norm({ x: -tang.y, y: tang.x }); // points "down" (into the solid body below)

      // â”€â”€ LEFT clip (anchor=refV1, tang=tang) â”€â”€
      const d0L = vm.dot(vm.sub(incV1, refV1), tang);
      const d1L = vm.dot(vm.sub(incV2, refV1), tang);
      const tL = isFinite(d0L / (d0L - d1L)) ? d0L / (d0L - d1L) : null;
      let leftClipPt = null, leftOut = [];
      if (d0L >= 0 && d1L >= 0) { leftOut = [{ ...incV1 }, { ...incV2 }]; }
      else if (d0L < 0 && d1L < 0) { leftOut = []; }
      else {
        leftClipPt = vm.add(incV1, vm.sc(vm.sub(incV2, incV1), tL));
        if (d0L >= 0) leftOut = [{ ...incV1 }, { ...leftClipPt }];
        else leftOut = [{ ...leftClipPt }, { ...incV2 }];
      }

      // â”€â”€ RIGHT clip (anchor=refV2, tang=negT) â”€â”€
      let d0R = null, d1R = null, tR = null, rightClipPt = null, rightOut = [];
      if (leftOut.length === 2) {
        const lo0 = leftOut[0], lo1 = leftOut[1];
        d0R = vm.dot(vm.sub(lo0, refV2), negT);
        d1R = vm.dot(vm.sub(lo1, refV2), negT);
        tR = isFinite(d0R / (d0R - d1R)) ? d0R / (d0R - d1R) : null;
        if (d0R >= 0 && d1R >= 0) { rightOut = [{ ...lo0 }, { ...lo1 }]; }
        else if (d0R < 0 && d1R < 0) { rightOut = []; }
        else {
          rightClipPt = vm.add(lo0, vm.sc(vm.sub(lo1, lo0), tR));
          if (d0R >= 0) rightOut = [{ ...lo0 }, { ...rightClipPt }];
          else rightOut = [{ ...rightClipPt }, { ...lo1 }];
        }
      }

      // â”€â”€ DEPTH FILTER: keep only points at or below the reference edge â”€â”€
      // refNormal points "inward" (down).
      // Inside = Positive depth. distance along normal.
      const refDist = vm.dot(refV1, refNormal);
      const candidatePoints = [...rightOut];
      const contactPoints = [];
      const depthValues = [];
      for (const p of candidatePoints) {
        const d = vm.dot(p, refNormal) - refDist;
        depthValues.push(d);
        if (d >= 0) contactPoints.push(p); // POSITIVE = INSIDE
      }

      G = {
        refV1, refV2, incV1, incV2, tang, negT, refNormal, refDist,
        d0L, d1L, tL, leftClipPt, leftOut,
        d0R, d1R, tR, rightClipPt, rightOut,
        candidatePoints, depthValues, contactPoints
      };
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // EASING
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const eO = t => 1 - (1 - t) * (1 - t);
    const eIO = t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DRAW PRIMITIVES
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function dDot(p, r, col, a = 1) {
      if (!p) return;
      cx.save(); cx.globalAlpha = a; cx.fillStyle = col;
      cx.beginPath(); cx.arc(p.x, p.y, r, 0, Math.PI * 2); cx.fill(); cx.restore();
    }
    function dLine(a, b, col, w = 2, dash = [], al = 1) {
      if (!a || !b) return;
      cx.save(); cx.globalAlpha = al; cx.strokeStyle = col; cx.lineWidth = w;
      cx.setLineDash(dash); cx.lineCap = 'round';
      cx.beginPath(); cx.moveTo(a.x, a.y); cx.lineTo(b.x, b.y); cx.stroke(); cx.restore();
    }
    function dArrow(f, t, col, w = 2, al = 1, hs = 10) {
      if (!f || !t) return;
      const d = Math.hypot(t.x - f.x, t.y - f.y);
      if (d < 2) return;
      cx.save(); cx.globalAlpha = al; cx.strokeStyle = col; cx.fillStyle = col; cx.lineWidth = w; cx.lineCap = 'round';
      cx.beginPath(); cx.moveTo(f.x, f.y); cx.lineTo(t.x, t.y); cx.stroke();
      const a = Math.atan2(t.y - f.y, t.x - f.x);
      cx.beginPath(); cx.moveTo(t.x, t.y);
      cx.lineTo(t.x - hs * Math.cos(a - .4), t.y - hs * Math.sin(a - .4));
      cx.lineTo(t.x - hs * Math.cos(a + .4), t.y - hs * Math.sin(a + .4));
      cx.closePath(); cx.fill(); cx.restore();
    }
    function pill(txt, p, bg, fg = '#fff', al = 1) {
      if (!p) return;
      cx.save();
      cx.shadowColor = 'transparent';
      cx.shadowBlur = 0;
      cx.font = 'bold 11px "JetBrains Mono",monospace';
      cx.textAlign = 'left';
      cx.textBaseline = 'alphabetic';
      const tw = cx.measureText(txt).width;
      const pad = 6, h = 20, r = 5;
      const bx = p.x - pad, by = p.y - 15, bw = tw + pad * 2, bh = h;
      // 1. Draw background at requested alpha
      cx.globalAlpha = al;
      cx.fillStyle = bg;
      cx.beginPath();
      if (cx.roundRect) {
        cx.roundRect(bx, by, bw, bh, r);
      } else {
        cx.moveTo(bx + r, by); cx.lineTo(bx + bw - r, by);
        cx.arcTo(bx + bw, by, bx + bw, by + r, r);
        cx.lineTo(bx + bw, by + bh - r);
        cx.arcTo(bx + bw, by + bh, bx + bw - r, by + bh, r);
        cx.lineTo(bx + r, by + bh);
        cx.arcTo(bx, by + bh, bx, by + bh - r, r);
        cx.lineTo(bx, by + r);
        cx.arcTo(bx, by, bx + r, by, r);
        cx.closePath();
      }
      cx.fill();
      // 2. Draw text ALWAYS at full opacity so it's always crisp and readable
      cx.globalAlpha = 1;
      cx.fillStyle = fg;
      cx.fillText(txt, p.x, p.y - 1);
      cx.restore();
    }
    function dShadeHalfPlane(p, n, col, al, label) {
      // Draw a large polygon representing the half-plane defined by point p and normal n.
      // We want to shade the side where dot(v-p, n) > 0.
      // Because we want to shade the "outside" or "above" region.
      // Actually the specific functions below decide what "outside" means.
      // Let's just draw a huge rectangle aligned with the edge.
      const w = 2000;
      const h = 2000;
      cx.save();
      cx.translate(p.x, p.y);
      // rotate so X axis aligns with the edge direction (perp to n).
      // n = (nx, ny). edge direction = (-ny, nx) if n is to our 'left' or 'right'?
      // We want to fill the region in direction n.
      // angle of n
      const ang = Math.atan2(n.y, n.x);
      cx.rotate(ang);
      // now we are in a frame where X is along n. We want to fill X > 0.
      cx.globalAlpha = al * .2; cx.fillStyle = col;
      cx.fillRect(0, -h / 2, w, h);
      cx.restore();

      // draw boundary line
      // line is perpendicular to n, passing through p
      const edgeDir = { x: -n.y, y: n.x };
      const p1 = vm.add(p, vm.sc(edgeDir, -1000));
      const p2 = vm.add(p, vm.sc(edgeDir, 1000));
      dLine(p1, p2, col, 1.5, [6, 4], al * .6);

      // label
      if (label) {
        // position label slightly "into" the shaded region
        const lp = vm.add(p, vm.sc(n, 40));
        pill(label, lp, col, '#fff', al * .9);
      }
    }

    function dShadeLeft(al) {
      // Left boundary at RefV1. Normal is -Tangent. "Outside" is direction of -Tangent.
      // We want to shade the region "behind" RefV1.
      dShadeHalfPlane(G.refV1, G.negT, '#ff4d6d', al, 'OUTSIDE (Back)');
    }
    function dShadeRight(al) {
      // Right boundary at RefV2. Normal is Tangent. "Outside" is direction of Tangent.
      dShadeHalfPlane(G.refV2, G.tang, '#ff4d6d', al, 'OUTSIDE (Front)');
    }
    // Shade ABOVE ref edge (for depth filter visual)
    function dShadeAbove(al) {
      // Reference Edge Plane. Normal is RefNormal.
      // We want to shade the "outside" region.
      // Our refNormal points "inward" (valid).
      // So we want to shade the opposite direction: -refNormal.
      const outN = vm.sc(G.refNormal, -1);
      dShadeHalfPlane(G.refV1, outN, '#ff4d6d', al, 'ABOVE EDGE â€” outside');
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ANIMATED STATE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let S = {};
    function resetS() {
      S = {
        ref: 0, inc: 0,
        shL: 0, tang: 0,
        tI1: 0, tI2: 0,
        pI1: 0, d0: 0, pI2: 0, d1: 0,
        pf: 0,
        // t animation: showFullVec = show the full ghost I1â†’I2, tFrac = animated 0â†’1 scaling
        showFullVec: 0, tFrac: 0,
        cpL: 0, lOut: 0,
        newInc: 0,
        shR: 0, negT: 0,
        tI1R: 0, tI2R: 0,
        pI1R: 0, d0R: 0, pI2R: 0, d1R: 0,
        pfR: 0,
        showFullVecR: 0, tFracR: 0,
        cpR: 0,
        // depth filter
        showCandidates: 0,
        showRefNorm: 0,
        showDepthShade: 0,
        showDepth0: 0, showDepth1: 0,
        showKept: 0,
        final: 0,
      };
    }
    resetS();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MAIN DRAW SCENE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function drawScene() {
      cx.clearRect(0, 0, W, H);
      // grid
      cx.save(); cx.strokeStyle = '#141925'; cx.lineWidth = 1;
      for (let x = 0; x < W; x += 40) { cx.beginPath(); cx.moveTo(x, 0); cx.lineTo(x, H); cx.stroke(); }
      for (let y = 0; y < H; y += 40) { cx.beginPath(); cx.moveTo(0, y); cx.lineTo(W, y); cx.stroke(); }
      cx.restore();

      const { refV1, refV2, incV1, incV2, tang, negT, refNormal,
        d0L, d1L, tL, leftClipPt, leftOut,
        d0R, d1R, tR, rightClipPt, rightOut,
        candidatePoints, depthValues, contactPoints } = G;

      // shade zones
      if (S.shL > 0) dShadeLeft(S.shL);
      if (S.shR > 0) dShadeRight(S.shR);
      if (S.showDepthShade > 0) dShadeAbove(S.showDepthShade);

      // â”€â”€ original incident edge â”€â”€
      if (S.inc > 0) {
        dLine(incV1, incV2, '#ff8c42', 2.5, [], S.inc);
        dDot(incV1, 7, '#ff8c42', S.inc); dDot(incV2, 7, '#ff8c42', S.inc);
        pill('IncV1', { x: incV1.x + 10, y: incV1.y - 10 }, '#ff8c42', '#fff', S.inc);
        pill('IncV2', { x: incV2.x + 10, y: incV2.y + 18 }, '#ff8c42', '#fff', S.inc);
      }

      // â”€â”€ reference edge â”€â”€
      if (S.ref > 0) {
        dLine(refV1, refV2, '#3ddc84', 3, [], S.ref);
        dDot(refV1, 7, '#3ddc84', S.ref); dDot(refV2, 7, '#3ddc84', S.ref);
        pill('RefV1', { x: refV1.x - 40, y: refV1.y - 14 }, '#3ddc84', '#fff', S.ref);
        pill('RefV2', { x: refV2.x + 10, y: refV2.y - 14 }, '#3ddc84', '#fff', S.ref);
      }

      // â”€â”€ tangent arrow â”€â”€
      if (S.tang > 0) {
        dArrow(refV1, vm.add(refV1, vm.sc(tang, 85)), '#4da6ff', 2.5, S.tang, 10);
        pill('TÌ‚  (tangent)', { x: refV1.x + 18, y: refV1.y - 18 }, '#4da6ff', '#fff', S.tang);
      }

      // â”€â”€ vectors RefV1 â†’ incident vertices â”€â”€
      if (S.tI1 > 0) dArrow(refV1, incV1, '#b48eff', 1.8, S.tI1, 8);
      if (S.tI2 > 0) dArrow(refV1, incV2, '#b48eff', 1.8, S.tI2, 8);

      // â”€â”€ projections + d labels (left phase) â”€â”€
      if (S.pI1 > 0) { const p = vm.proj(incV1, refV1, tang); dLine(incV1, p, '#b48eff', 1.5, [4, 4], S.pI1); dDot(p, 5, '#b48eff', S.pI1); }
      if (S.d0 > 0) {
        const p = vm.proj(incV1, refV1, tang);
        const sg = d0L >= 0 ? '+' : '';
        pill(`d0 = ${sg}${d0L.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d0L >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d0);
      }
      if (S.pI2 > 0) { const p = vm.proj(incV2, refV1, tang); dLine(incV2, p, '#b48eff', 1.5, [4, 4], S.pI2); dDot(p, 5, '#b48eff', S.pI2); }
      if (S.d1 > 0) {
        const p = vm.proj(incV2, refV1, tang);
        const sg = d1L >= 0 ? '+' : '';
        pill(`d1 = ${sg}${d1L.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d1L >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d1);
      }

      // â”€â”€ pass/fail rings (left) â”€â”€
      if (S.pf > 0) {
        const c0 = d0L >= 0 ? '#3ddc84' : '#ff4d6d', c1 = d1L >= 0 ? '#3ddc84' : '#ff4d6d';
        dDot(incV1, 16, c0, S.pf * .22); dDot(incV2, 16, c1, S.pf * .22);
        cx.save(); cx.globalAlpha = S.pf; cx.textAlign = 'center'; cx.textBaseline = 'middle';
        cx.font = 'bold 14px sans-serif';
        cx.fillStyle = c0; cx.fillText(d0L >= 0 ? 'âœ“' : 'âœ—', incV1.x, incV1.y);
        cx.fillStyle = c1; cx.fillText(d1L >= 0 ? 'âœ“' : 'âœ—', incV2.x, incV2.y);
        cx.restore();
      }

      // â”€â”€ t ANIMATION (left) â€” full vector first, then animated shrinking â”€â”€
      if (S.showFullVec > 0) {
        // ghost of the full I1â†’I2 vector
        dLine(incV1, incV2, '#ff4d6d', 1.5, [], S.showFullVec * .45);
        dArrow(incV1, incV2, '#ff4d6d', 1, S.showFullVec * .4, 7);
        pill('IncV1 â†’ IncV2 (full edge)', { x: incV1.x + 10, y: incV1.y + 18 }, '#ff4d6d', '#fff', S.showFullVec * .8);
      }
      if (S.tFrac > 0 && tL !== null) {
        // growing arrow from I1, scaled by t
        const end = vm.add(incV1, vm.sc(vm.sub(incV2, incV1), S.tFrac * tL));
        dArrow(incV1, end, '#ff4d6d', 3, Math.min(1, S.tFrac * 3), 11);
        const tv = (S.tFrac * tL).toFixed(3);
        pill(`t = ${tv}  â†’  growing...`, { x: incV1.x + 12, y: incV1.y - 26 }, '#ff4d6d', '#fff', Math.min(1, S.tFrac * 3));
      }

      // â”€â”€ left clip point â”€â”€
      if (S.cpL > 0 && leftClipPt) {
        dDot(leftClipPt, 9, '#ff4d6d', S.cpL);
        pill('Clip Point (Left)', { x: leftClipPt.x + 10, y: leftClipPt.y + 20 }, '#ff4d6d', '#fff', S.cpL);
      }

      // â”€â”€ left clip output (dashed) â”€â”€
      if (S.lOut > 0 && leftOut.length === 2) {
        dLine(leftOut[0], leftOut[1], '#ff4d6d', 2.5, [8, 5], S.lOut);
        dDot(leftOut[0], 7, '#ff4d6d', S.lOut); dDot(leftOut[1], 7, '#ff4d6d', S.lOut);
      }

      // â•â• RIGHT CLIP PHASE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // new clean incident
      if (S.newInc > 0 && leftOut.length === 2) {
        dLine(leftOut[0], leftOut[1], '#ff8c42', 3, [], S.newInc);
        dDot(leftOut[0], 8, '#ff8c42', S.newInc); dDot(leftOut[1], 8, '#ff8c42', S.newInc);
        pill('NewV1', { x: leftOut[0].x + 10, y: leftOut[0].y + 20 }, '#ff8c42', '#fff', S.newInc);
        pill('NewV2', { x: leftOut[1].x + 10, y: leftOut[1].y - 14 }, '#ff8c42', '#fff', S.newInc);
      }
      // neg tang
      if (S.negT > 0) {
        dArrow(refV2, vm.add(refV2, vm.sc(negT, 85)), '#4da6ff', 2.5, S.negT, 10);
        pill('âˆ’TÌ‚  (reversed)', { x: refV2.x - 100, y: refV2.y - 18 }, '#4da6ff', '#fff', S.negT);
      }
      if (S.tI1R > 0 && leftOut.length === 2) dArrow(refV2, leftOut[0], '#b48eff', 1.8, S.tI1R, 8);
      if (S.tI2R > 0 && leftOut.length === 2) dArrow(refV2, leftOut[1], '#b48eff', 1.8, S.tI2R, 8);
      if (S.pI1R > 0 && leftOut.length === 2) { const p = vm.proj(leftOut[0], refV2, negT); dLine(leftOut[0], p, '#b48eff', 1.5, [4, 4], S.pI1R); dDot(p, 5, '#b48eff', S.pI1R); }
      if (S.d0R > 0 && d0R !== null) {
        const p = vm.proj(leftOut[0], refV2, negT);
        pill(`d0 = ${d0R >= 0 ? '+' : ''}${d0R.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d0R >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d0R);
      }
      if (S.pI2R > 0 && leftOut.length === 2) { const p = vm.proj(leftOut[1], refV2, negT); dLine(leftOut[1], p, '#b48eff', 1.5, [4, 4], S.pI2R); dDot(p, 5, '#b48eff', S.pI2R); }
      if (S.d1R > 0 && d1R !== null) {
        const p = vm.proj(leftOut[1], refV2, negT);
        pill(`d1 = ${d1R >= 0 ? '+' : ''}${d1R.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d1R >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d1R);
      }
      if (S.pfR > 0 && leftOut.length === 2) {
        const c0 = d0R >= 0 ? '#3ddc84' : '#ff4d6d', c1 = d1R >= 0 ? '#3ddc84' : '#ff4d6d';
        dDot(leftOut[0], 16, c0, S.pfR * .22); dDot(leftOut[1], 16, c1, S.pfR * .22);
        cx.save(); cx.globalAlpha = S.pfR; cx.textAlign = 'center'; cx.textBaseline = 'middle';
        cx.font = 'bold 14px sans-serif';
        cx.fillStyle = c0; cx.fillText(d0R >= 0 ? 'âœ“' : 'âœ—', leftOut[0].x, leftOut[0].y);
        cx.fillStyle = c1; cx.fillText(d1R >= 0 ? 'âœ“' : 'âœ—', leftOut[1].x, leftOut[1].y);
        cx.restore();
      }
      // t animation RIGHT
      if (S.showFullVecR > 0 && leftOut.length === 2) {
        dLine(leftOut[0], leftOut[1], '#ff4d6d', 1.5, [], S.showFullVecR * .45);
        dArrow(leftOut[0], leftOut[1], '#ff4d6d', 1, S.showFullVecR * .4, 7);
        pill('NewV1 â†’ NewV2 (full edge)', { x: leftOut[0].x + 10, y: leftOut[0].y - 26 }, '#ff4d6d', '#fff', S.showFullVecR * .8);
      }
      if (S.tFracR > 0 && tR !== null && leftOut.length === 2) {
        const lo0 = leftOut[0], lo1 = leftOut[1];
        const end = vm.add(lo0, vm.sc(vm.sub(lo1, lo0), S.tFracR * tR));
        dArrow(lo0, end, '#ff4d6d', 3, Math.min(1, S.tFracR * 3), 11);
        pill(`t = ${(S.tFracR * tR).toFixed(3)}  â†’  growing...`, { x: lo0.x + 12, y: lo0.y - 26 }, '#ff4d6d', '#fff', Math.min(1, S.tFracR * 3));
      }
      if (S.cpR > 0 && rightClipPt) {
        dDot(rightClipPt, 9, '#ff4d6d', S.cpR);
        pill('Clip Point (Right)', { x: rightClipPt.x + 10, y: rightClipPt.y + 20 }, '#ff4d6d', '#fff', S.cpR);
      }

      // â•â• DEPTH FILTER PHASE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (S.showCandidates > 0) {
        // show the right-clip output as candidate points
        for (let i = 0; i < candidatePoints.length; i++) {
          const p = candidatePoints[i];
          dDot(p, 10, '#b48eff', S.showCandidates);
          pill(`Candidate ${i + 1}`, { x: p.x + 12, y: p.y - 10 }, '#b48eff', '#fff', S.showCandidates);
        }
        if (rightOut.length === 2) dLine(rightOut[0], rightOut[1], '#b48eff', 2, [4, 4], S.showCandidates * .7);
      }

      // show Normal
      if (S.showRefNorm > 0) {
        // midpoint
        const mx = (refV1.x + refV2.x) * 0.5;
        const my = (refV1.y + refV2.y) * 0.5;
        const mid = { x: mx, y: my };
        const end = vm.add(mid, vm.sc(refNormal, 50));
        dArrow(mid, end, '#ffd166', 3, S.showRefNorm, 12);
        pill('n (normal)', { x: end.x, y: end.y + 20 }, '#ffd166', '#0b0d12', S.showRefNorm);
      }

      // depth measurements
      if (S.showDepth0 > 0 && candidatePoints.length > 0) {
        const p = candidatePoints[0], d = depthValues[0];
        // draw a vertical line from the point down to the reference line (or up)
        const refY = refV1.y;
        dLine(p, { x: p.x, y: refY }, '#ffd166', 1.5, [4, 4], S.showDepth0);
        dDot({ x: p.x, y: refY }, 5, '#ffd166', S.showDepth0);
        const sign = d <= 0 ? 'â‰¤ 0' : '> 0';
        const col = d <= 0 ? '#3ddc84' : '#ff4d6d';
        pill(`depth = ${d.toFixed(1)} (${sign})`, { x: p.x + 8, y: (p.y + refY) / 2 }, col, '#fff', S.showDepth0);
      }
      if (S.showDepth1 > 0 && candidatePoints.length > 1) {
        const p = candidatePoints[1], d = depthValues[1];
        const refY = refV1.y;
        dLine(p, { x: p.x, y: refY }, '#ffd166', 1.5, [4, 4], S.showDepth1);
        dDot({ x: p.x, y: refY }, 5, '#ffd166', S.showDepth1);
        const sign = d <= 0 ? 'â‰¤ 0' : '> 0';
        const col = d <= 0 ? '#3ddc84' : '#ff4d6d';
        pill(`depth = ${d.toFixed(1)} (${sign})`, { x: p.x + 8, y: (p.y + refY) / 2 }, col, '#fff', S.showDepth1);
      }

      // kept contact points
      if (S.showKept > 0) {
        for (const p of contactPoints) {
          dDot(p, 12, '#ffd166', S.showKept);
          cx.save(); cx.globalAlpha = S.showKept; cx.fillStyle = '#ffd166';
          cx.font = 'bold 13px sans-serif'; cx.textAlign = 'center'; cx.textBaseline = 'middle';
          cx.fillText('âœ“', p.x, p.y); cx.restore();
        }
      }

      // â”€â”€ FINAL â”€â”€
      if (S.final > 0 && contactPoints.length === 2) {
        cx.save(); cx.globalAlpha = S.final * .2; cx.strokeStyle = '#ffd166'; cx.lineWidth = 16; cx.lineCap = 'round';
        cx.beginPath(); cx.moveTo(contactPoints[0].x, contactPoints[0].y);
        cx.lineTo(contactPoints[1].x, contactPoints[1].y); cx.stroke(); cx.restore();
        dLine(contactPoints[0], contactPoints[1], '#ffd166', 4, [], S.final);
        dDot(contactPoints[0], 9, '#ffd166', S.final); dDot(contactPoints[1], 9, '#ffd166', S.final);
        const mx = (contactPoints[0].x + contactPoints[1].x) / 2;
        const my = (contactPoints[0].y + contactPoints[1].y) / 2;
        pill('âœ“  Final Contact Edge', { x: mx - 66, y: my - 18 }, '#ffd166', '#0b0d12', S.final);
      } else if (S.final > 0 && contactPoints.length === 1) {
        dDot(contactPoints[0], 9, '#ffd166', S.final);
        pill('âœ“  Single Contact Point', { x: contactPoints[0].x + 10, y: contactPoints[0].y - 18 }, '#ffd166', '#0b0d12', S.final);
      } else if (S.final > 0 && contactPoints.length === 0) {
        pill('No Contact â€” edges do not intersect', { x: W / 2 - 110, y: H / 2 }, '#ff4d6d', '#fff', S.final);
      }

      // â”€â”€ DRAG HANDLES on ready screen â”€â”€
      if (curStep < 0) {
        const pts = [
          { p: G.refV1, c: '#3ddc84' }, { p: G.refV2, c: '#3ddc84' },
          { p: G.incV1, c: '#ff8c42' }, { p: G.incV2, c: '#ff8c42' }
        ];
        dLine(G.refV1, G.refV2, '#3ddc84', 2, [], 0.6);
        dLine(G.incV1, G.incV2, '#ff8c42', 2, [], 0.6);
        for (const { p, c } of pts) {
          cx.save(); cx.globalAlpha = .55; cx.strokeStyle = c; cx.lineWidth = 2; cx.setLineDash([3, 3]);
          cx.beginPath(); cx.arc(p.x, p.y, 17, 0, Math.PI * 2); cx.stroke(); cx.restore();
          dDot(p, 7, c, .95);
        }
        pill('RefV1', { x: G.refV1.x - 40, y: G.refV1.y - 14 }, '#3ddc84', '#fff', .85);
        pill('RefV2', { x: G.refV2.x + 10, y: G.refV2.y - 14 }, '#3ddc84', '#fff', .85);
        pill('IncV1', { x: G.incV1.x + 10, y: G.incV1.y - 14 }, '#ff8c42', '#fff', .85);
        pill('IncV2', { x: G.incV2.x + 10, y: G.incV2.y + 18 }, '#ff8c42', '#fff', .85);
        // hint text
        cx.save(); cx.globalAlpha = .45; cx.fillStyle = '#5a6480';
        cx.font = 'bold 11px "JetBrains Mono",monospace'; cx.textAlign = 'center';
        cx.fillText('â† drag vertices to reposition â†’', W / 2, H - 12); cx.restore();
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DRAG ON CANVAS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let dragV = null;
    const dragMap = [
      { get: () => G.refV1, sx: 'rv1x', sy: 'rv1y' },
      { get: () => G.refV2, sx: 'rv2x', sy: 'rv2y' },
      { get: () => G.incV1, sx: 'iv1x', sy: 'iv1y' },
      { get: () => G.incV2, sx: 'iv2x', sy: 'iv2y' },
    ];
    function cXY(e) {
      const r = CV.getBoundingClientRect();
      const src = e.touches ? e.touches[0] : e;
      return { x: (src.clientX - r.left) * W / r.width, y: (src.clientY - r.top) * H / r.height };
    }
    CV.addEventListener('mousedown', e => {
      if (curStep >= 0) return;
      const { x, y } = cXY(e);
      let found = null;
      for (const vm of dragMap) {
        const p = vm.get();
        if (Math.hypot(p.x - x, p.y - y) < 30) { found = vm; break; }
      }
      if (found) { dragV = found; CV.classList.add('drag'); }
    });
    CV.addEventListener('mousemove', e => {
      if (!dragV) return;
      const { x, y } = cXY(e);
      // X
      const sx = document.getElementById(dragV.sx);
      sx.value = Math.min(+sx.max, Math.max(+sx.min, Math.round(x)));
      document.getElementById(dragV.sx + '-v').textContent = sx.value;
      // Y
      const sy = document.getElementById(dragV.sy);
      sy.value = Math.min(+sy.max, Math.max(+sy.min, Math.round(y)));
      document.getElementById(dragV.sy + '-v').textContent = sy.value;

      computeGeo(); drawScene();
    });
    CV.addEventListener('mouseup', () => { dragV = null; CV.classList.remove('drag'); });
    CV.addEventListener('mouseleave', () => { dragV = null; CV.classList.remove('drag'); });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // SLIDERS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ['rv1x', 'rv1y', 'rv2x', 'rv2y', 'iv1x', 'iv1y', 'iv2x', 'iv2y'].forEach(id => {
      const el = document.getElementById(id);
      const vl = document.getElementById(id + '-v');
      vl.textContent = el.value;
      el.addEventListener('input', () => { vl.textContent = el.value; computeGeo(); if (curStep < 0) drawScene(); });
    });

    // collapsible
    document.getElementById('ctrl-toggle').addEventListener('click', () => {
      const tog = document.getElementById('ctrl-toggle');
      const bod = document.getElementById('ctrl-body');
      const open = bod.classList.toggle('open');
      tog.classList.toggle('open', open);
      tog.textContent = open ? 'â–¼ Edge Controls (collapse)' : 'â–¶ Edge Controls (expand to adjust positions)';
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TTS â€” Best available male voice, clear for tutorials
    // Priority: Google UK English Male > Daniel (en-GB) > Google US English >
    //           any name containing 'male' > any en-GB > any en-US
    // Pitch set low (0.85) to sound male even on fallback voices.
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let ttsOn = true;
    let chosenVoice = null;

    const MALE_VOICE_PRIORITY = [
      'Microsoft Aria Online (Natural) - English (United States)',
      'Microsoft Jenny Online (Natural) - English (United States)',
      'Microsoft Guy Online (Natural) - English (United States)',
      'Google US English',
      'Samantha',
      'Google UK English Female',
      'Google UK English Male',
      'Daniel',
      'Microsoft Zira Desktop - English (United States)'
    ];

    function pickVoice() {
      const voices = speechSynthesis.getVoices();
      if (!voices.length) return;

      // 1. Exact name match from priority list
      for (const name of MALE_VOICE_PRIORITY) {
        const found = voices.find(v => v.name.includes(name) || v.name === name);
        if (found) { chosenVoice = found; return; }
      }
      // 2. Name contains 'natural' or 'online' (case-insensitive)
      const naturalName = voices.find(v => v.name.toLowerCase().includes('natural') || v.name.toLowerCase().includes('online'));
      if (naturalName) { chosenVoice = naturalName; return; }
      // 3. en-US any
      const enUS = voices.find(v => v.lang === 'en-US');
      if (enUS) { chosenVoice = enUS; return; }
      // 4. en-GB any
      const enGB = voices.find(v => v.lang === 'en-GB');
      if (enGB) { chosenVoice = enGB; return; }
      // 5. Any English
      const en = voices.find(v => v.lang.startsWith('en'));
      if (en) { chosenVoice = en; return; }
    }

    // voices load async in many browsers
    if (typeof speechSynthesis !== 'undefined') {
      speechSynthesis.onvoiceschanged = pickVoice;
      pickVoice();
      // retry after a tick â€” some browsers need this
      setTimeout(pickVoice, 200);
      setTimeout(pickVoice, 1000);
    }



    function speak(txt) {
      const descBox = document.getElementById('step-desc');
      if (descBox && txt) {
        descBox.innerHTML = txt;
      }

      if (!ttsOn || !window.speechSynthesis) return;
      speechSynthesis.cancel();
      // re-attempt voice pick in case voices loaded late
      if (!chosenVoice) pickVoice();
      const clean = txt.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
      const u = new SpeechSynthesisUtterance(clean);
      if (chosenVoice) u.voice = chosenVoice;
      u.lang = 'en-US';
      u.rate = 1.0;
      u.pitch = 1.0;

      // Duck background music
      if (window.bgMusicDuck) window.bgMusicDuck();

      u.onend = () => {
        if (window.bgMusicRestore) window.bgMusicRestore();
      };
      u.onerror = () => {
        if (window.bgMusicRestore) window.bgMusicRestore();
      };

      speechSynthesis.speak(u);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // STEP BUILDER
    // Names spoken in full: "Reference Vertex 1", "Incident Vertex 1", etc.
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function buildSteps() {
      const { d0L, d1L, tL, leftClipPt, leftOut, d0R, d1R, tR, rightClipPt, rightOut,
        candidatePoints, depthValues, contactPoints } = G;

      const crossesL = (d0L >= 0) !== (d1L >= 0);
      const crossesR = d0R !== null && ((d0R >= 0) !== (d1R >= 0));

      // Helper: human readable names
      const incV1name = 'Incident Vertex 1', incV2name = 'Incident Vertex 2';
      const refV1name = 'Reference Vertex 1', refV2name = 'Reference Vertex 2';
      const iv1in = d0L >= 0, iv2in = d1L >= 0;

      let stepNum = 0;
      const S_ = () => `Step ${++stepNum}`;

      const steps = [
        // â”€â”€ 1: Introduction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          title: `${S_()} â€” The Two Edges`,
          say: `Let us get started. Here we have two edges. The green one is the Reference Edge. In a physics collision, this is the edge on the polygon that has the least penetration depth â€” meaning it's the face being hit first. It acts as our solid boundary wall. The orange one is the Incident Edge â€” the edge from the other polygon that is crashing into it.`,
          desc: `<b style="color:#3ddc84">Green = Reference Edge</b> â€” the edge with least penetration (the face being hit).<br><b style="color:#ff8c42">Orange = Incident Edge</b> â€” the edge crashing into the reference face.`,
          dur: 1100, enter(t) { S.ref = eO(t); S.inc = eO(t); }
        },
        // â”€â”€ 2: Tangent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          title: `${S_()} â€” The Tangent Vector`,
          say: `First, we compute the tangent vector of the reference edge. The tangent just points in the same direction as the edge â€” from ${refV1name} toward ${refV2name}. We then normalize it, which means we shrink it so its length becomes exactly 1. Now it is just a direction arrow. We call this T-hat.`,
          desc: `<code>TÌ‚ = normalize(${refV2name} âˆ’ ${refV1name})</code><br>A unit vector pointing along the reference edge â€” tells us the "forward" direction.`,
          dur: 950, enter(t) { S.tang = eO(t); }
        },
        // â”€â”€ 3: Vectors to incident verts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          title: `${S_()} â€” Draw Vectors to Incident Vertices`,
          say: `Now we draw a vector from ${refV1name} to each endpoint of the incident edge. These arrows help us measure how far "along" the reference boundary each incident point is. Think of it as asking: is this point ahead of ${refV1name} or behind it?`,
          desc: `Arrows from <b style="color:#3ddc84">${refV1name}</b> â†’ <b style="color:#ff8c42">${incV1name}</b> and <b style="color:#ff8c42">${incV2name}</b>.<br>These let us measure each vertex against the boundary anchor.`,
          dur: 950, enter(t) { S.tI1 = eO(Math.min(1, t * 2)); S.tI2 = eO(Math.max(0, t * 2 - 1)); }
        },
        // â”€â”€ 4: Project I1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          title: `${S_()} â€” Measure ${incV1name}: dot product d0`,
          say: `We now project ${incV1name} onto the tangent using the dot product. The dot product gives us a single number called d0. If d0 is positive, ${incV1name} is ahead of ${refV1name} â€” meaning it is inside the left boundary. If d0 is negative, ${incV1name} is behind ${refV1name} â€” it is outside. The dashed line shows where ${incV1name} drops perpendicularly onto the reference line.`,
          desc: `<code>d0 = dot(${incV1name} âˆ’ ${refV1name},  TÌ‚) = ${d0L.toFixed(1)}</code><br>Dashed line = perpendicular drop to the reference line.<br><b style="color:${d0L >= 0 ? '#3ddc84' : '#ff4d6d'}">${d0L >= 0 ? `d0 > 0  â†’  ${incV1name} is INSIDE the left boundary âœ“` : `d0 < 0  â†’  ${incV1name} is OUTSIDE the left boundary âœ—`}</b>`,
          dur: 1100, enter(t) { S.pI1 = eO(t); S.d0 = eO(t); }
        },
        // â”€â”€ 5: Project I2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          title: `${S_()} â€” Measure ${incV2name}: dot product d1`,
          say: `Same process for ${incV2name}. We drop it perpendicularly onto the reference line and compute d1 using the dot product. Check the sign â€” positive means inside, negative means outside.`,
          desc: `<code>d1 = dot(${incV2name} âˆ’ ${refV1name},  TÌ‚) = ${d1L.toFixed(1)}</code><br><b style="color:${d1L >= 0 ? '#3ddc84' : '#ff4d6d'}">${d1L >= 0 ? `d1 > 0  â†’  ${incV2name} is INSIDE âœ“` : `d1 < 0  â†’  ${incV2name} is OUTSIDE âœ—`}</b>`,
          dur: 1000, enter(t) { S.pI2 = eO(t); S.d1 = eO(t); }
        },
        // â”€â”€ 6: Left boundary check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          title: `${S_()} â€” Left Boundary: Pass or Fail?`,
          say: `The red shaded region on the left is the outside zone â€” anything there is beyond ${refV1name} and needs to be removed. ${incV1name} ${iv1in ? 'passes because d0 is positive' : 'fails because d0 is negative'}, and ${incV2name} ${iv2in ? 'passes because d1 is positive' : 'fails because d1 is negative'}. ${crossesL ? 'Since one is inside and one is outside, the edge must cross the left boundary somewhere in the middle. We need to find exactly where.' : iv1in && iv2in ? 'Both pass! No left clipping is needed.' : 'Both fail! The entire edge is outside the left boundary â€” nothing survives.'}`,
          desc: `Red zone = outside (behind ${refV1name}).<br><b style="color:${iv1in ? '#3ddc84' : '#ff4d6d'}">${incV1name}: ${iv1in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b>   <b style="color:${iv2in ? '#3ddc84' : '#ff4d6d'}">${incV2name}: ${iv2in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b>`,
          dur: 1150, enter(t) { S.shL = eO(t); S.pf = eO(t); }
        },
      ];

      if (crossesL) {
        steps.push(
          // â”€â”€ 7: Show full vector first â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          {
            title: `${S_()} â€” The Incident Edge as a Vector`,
            say: `Before we find the crossing, let us look at the incident edge as a vector â€” an arrow starting at ${incV1name} and pointing toward ${incV2name}. This arrow represents the full path from one vertex to the other. In the next step, we will use a fraction called t to travel along this arrow and find exactly where it crosses the boundary.`,
            desc: `The full incident edge seen as a vector: <b style="color:#ff4d6d">${incV1name} â†’ ${incV2name}</b>.<br>We will walk along this arrow using a fraction t (0 = start, 1 = end) to find the boundary crossing.`,
            dur: 1000, enter(t) { S.showFullVec = eO(t); }
          },
          // â”€â”€ 8: t animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          {
            title: `${S_()} â€” Find the Crossing Point with t`,
            say: `Here is the key insight. We compute a number t using this formula: t equals d0 divided by the quantity d0 minus d1. Because d0 and d1 have opposite signs â€” one positive, one negative â€” their difference makes t land between 0 and 1. Think of t as a percentage: 0% means we are at ${incV1name}, 100% means we are at ${incV2name}. So t tells us exactly how far along the edge the boundary crossing happens. Watch the red arrow grow from ${incV1name} toward ${incV2name} â€” it stops right at the boundary!`,
            desc: `<code>t = d0 / (d0 âˆ’ d1) = ${tL !== null ? tL.toFixed(4) : 'N/A'}</code><br>Since d0 and d1 have <b>opposite signs</b>, t is always between 0 and 1.<br>t is the <b>percentage along the edge</b> where it crosses the boundary.<br>Watch the arrow grow and stop at the crossing!`,
            dur: 2200, enter(t) { S.showFullVec = 1; S.tFrac = eIO(t); }
          },
          // â”€â”€ 9: Place clip point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          {
            title: `${S_()} â€” Compute & Place the Clip Point`,
            say: `Now we use t to compute the actual clip point. The formula is: ${incV1name} plus t times the difference from ${incV1name} to ${incV2name}. Because t is between 0 and 1, this new point lies exactly on the boundary line. It replaces the vertex that was outside.`,
            desc: `<code>ClipPoint = ${incV1name} + t Ã— (${incV2name} âˆ’ ${incV1name})</code><br>This new point lies exactly on the left boundary.`,
            dur: 850, enter(t) { S.cpL = eO(t); }
          }
        );
      }

      steps.push(
        // â”€â”€ Left clip result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          title: `${S_()} â€” Left Clip Result`,
          say: `After the left clip, we discard the vertex that was outside and keep the one that was inside, plus the new clip point we just created. ${leftOut.length === 0 ? 'In this case both vertices were outside, so the entire incident edge is clipped away â€” nothing remains.' : 'The dashed red line shows our new incident edge. This becomes the starting point for the right clip.'}`,
          desc: `Left clip complete. Keeping: <b style="color:#ff4d6d">${leftOut.length === 0 ? 'nothing (fully clipped away)' : crossesL ? '[surviving vertex + Clip Point]' : '[both vertices â€” no clip needed]'}</b><br>${leftOut.length === 2 ? 'Dashed red = new incident edge going into the right clip phase.' : ''}`,
          dur: 950, enter(t) { S.lOut = eO(t); }
        }
      );

      if (leftOut.length === 2) {
        const lo0in = d0R >= 0, lo1in = d1R >= 0;
        steps.push(
          // â”€â”€ Transition to right clip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          {
            title: `${S_()} â€” Start Right Clip: New Incident Edge`,
            say: `Now we begin the right clip. The output from the left clip â€” the two vertices we kept â€” becomes our brand new incident edge. We completely forget the original orange edge. The question now is: does any part of this trimmed edge go past ${refV2name} on the right side?`,
            desc: `Left-clip output becomes the <b style="color:#ff8c42">new incident edge</b> for the right clip.<br>We work only with these two vertices from here on.`,
            dur: 1050, enter(t) {
              const fade = Math.max(0, 1 - t * 2.8);
              S.inc = fade; S.lOut = fade; S.pf = fade; S.shL = fade;
              S.pI1 = fade; S.d0 = fade; S.pI2 = fade; S.d1 = fade;
              S.tI1 = fade; S.tI2 = fade; S.tang = fade;
              S.showFullVec = fade; S.tFrac = fade; S.cpL = fade;
              S.newInc = eO(Math.max(0, t * 2 - .6));
            }
          },
          // â”€â”€ Reverse tangent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          {
            title: `${S_()} â€” Flip the Tangent for the Right Clip`,
            say: `For the right clip, we reverse the tangent direction. We multiply T-hat by negative 1. Now the arrow points from right to left. This flipping means the "inside" direction becomes everything to the left of ${refV2name}. We also switch our anchor from ${refV1name} to ${refV2name}.`,
            desc: `<code>âˆ’TÌ‚ = TÌ‚ Ã— âˆ’1</code> â€” now points right to left. Anchor = <b style="color:#3ddc84">${refV2name}</b>.<br>Anything past ${refV2name} on the right is now the outside zone.`,
            dur: 950, enter(t) { S.negT = eO(t); S.shR = eO(t); }
          },
          // â”€â”€ Vectors from RefV2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          {
            title: `${S_()} â€” Vectors from ${refV2name} to New Vertices`,
            say: `We draw vectors from ${refV2name} to each vertex of the new incident edge. We will then project these onto the reversed tangent to get dot products d0 and d1 for the right clip.`,
            desc: `Arrows from <b style="color:#3ddc84">${refV2name}</b> to each vertex of the new incident edge.<br>Project onto âˆ’TÌ‚ to measure each vertex.`,
            dur: 950, enter(t) { S.tI1R = eO(Math.min(1, t * 2)); S.tI2R = eO(Math.max(0, t * 2 - 1)); }
          },
          // â”€â”€ Right boundary check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          {
            title: `${S_()} â€” Right Boundary: Pass or Fail?`,
            say: `We project both new vertices onto the reversed tangent and compute d0 and d1. ${lo0in ? 'New Vertex 1 is inside the right boundary â€” d0 is positive.' : 'New Vertex 1 is outside the right boundary â€” d0 is negative.'} ${lo1in ? 'New Vertex 2 is inside â€” d1 is positive.' : 'New Vertex 2 is outside â€” d1 is negative.'} ${crossesR ? 'One is outside, so we need to clip again.' : 'Both are inside â€” no right clipping needed! The edge fits perfectly.'}`,
            desc: `<code>d0 = dot(New Vertex 1 âˆ’ ${refV2name}, âˆ’TÌ‚) = ${d0R !== null ? d0R.toFixed(1) : '?'}</code> â†’ <b style="color:${lo0in ? '#3ddc84' : '#ff4d6d'}">${lo0in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b><br><code>d1 = dot(New Vertex 2 âˆ’ ${refV2name}, âˆ’TÌ‚) = ${d1R !== null ? d1R.toFixed(1) : '?'}</code> â†’ <b style="color:${lo1in ? '#3ddc84' : '#ff4d6d'}">${lo1in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b>`,
            dur: 1150, enter(t) {
              S.pI1R = eO(Math.min(1, t * 2)); S.d0R = eO(Math.min(1, t * 2));
              S.pI2R = eO(Math.max(0, t * 2 - 1)); S.d1R = eO(Math.max(0, t * 2 - 1));
              S.pfR = eO(t);
            }
          }
        );

        if (crossesR) {
          steps.push(
            // â”€â”€ Show full right vector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            {
              title: `${S_()} â€” The New Edge as a Vector (Right Clip)`,
              say: `We look at the new incident edge as a vector arrow from New Vertex 1 to New Vertex 2. We will walk along this arrow using a new t value to find exactly where it crosses the right boundary at ${refV2name}.`,
              desc: `New incident edge as a vector: <b style="color:#ff4d6d">New Vertex 1 â†’ New Vertex 2</b>.<br>We will compute t again to find the right boundary crossing.`,
              dur: 950, enter(t) { S.showFullVecR = eO(t); }
            },
            // â”€â”€ t animation right â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            {
              title: `${S_()} â€” Find the Right Crossing with t`,
              say: `We complete t using the formula: t equals d0 divided by d0 minus d1. Since the two dot products have opposite signs, t lands between 0 and 1. Watch the arrow grow from New Vertex 1 toward New Vertex 2, stopping exactly where the edge crosses ${refV2name}.`,
              desc: `<code>t = d0 / (d0 âˆ’ d1) = ${tR !== null ? tR.toFixed(4) : 'N/A'}</code><br>t is a fraction 0â†’1 along the edge.<br>Watch the arrow grow and stop at the right boundary!`,
              dur: 2200, enter(t) { S.showFullVecR = 1; S.tFracR = eIO(t); }
            },
            // â”€â”€ Right clip point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            {
              title: `${S_()} â€” Place the Right Clip Point`,
              say: `Using t, we compute the right clip point as New Vertex 1 plus t times the direction from New Vertex 1 to New Vertex 2. This new point lands exactly on the right boundary at ${refV2name}. We now have both endpoints of our clipped edge.`,
              desc: `<code>ClipPoint = New Vertex 1 + t Ã— (New Vertex 2 âˆ’ New Vertex 1)</code><br>This point lies exactly on the right boundary.`,
              dur: 850, enter(t) { S.cpR = eO(t); }
            }
          );
        }

        // â”€â”€ Depth filter phase â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        steps.push(
          {
            title: `${S_()} â€” After Clipping: Show Candidate Points`,
            say: `After both left and right clipping, we have up to two candidate points â€” the survivors. But we are not done yet! We need one final check. Some of these surviving points might be above the reference edge, meaning they are not actually touching it. We need to remove any points that are above the boundary â€” we only want to keep the ones that are at or below the reference edge.`,
            desc: `Clipping done! Here are the <b style="color:#b48eff">candidate contact points</b>.<br>Final step: filter out any points that are <b>above</b> the reference edge â€” they don't actually touch it.`,
            dur: 1000, enter(t) {
              S.showCandidates = eO(t);
              // Visual cleanup of Right Clip stage
              const fade = Math.max(0, 1 - t * 2.8);
              S.shR = fade; S.negT = fade;
              S.newInc = fade;
              S.tI1R = fade; S.tI2R = fade;
              S.pI1R = fade; S.d0R = fade; S.pI2R = fade; S.d1R = fade;
              S.pfR = fade;
              S.showFullVecR = fade; S.tFracR = fade;
              S.cpR = fade;
            }
          },
          {
            title: `${S_()} â€” The Reference Normal`,
            say: `To check which side of the reference edge each point is on, we use the Reference Normal. This is a vector that points perpendicular to the edge â€” straight 'down' into the solid object. It defines the "inside" direction.`,
            desc: `<code>refNormal</code> = vector perpendicular to the reference edge, pointing "inward".<br>This tells us which way is "inside" the reference face.`,
            dur: 1000, enter(t) { S.showRefNorm = eO(t); S.showCandidates = 1; }
          },
          {
            title: `${S_()} â€” The Clipping Boundary`,
            say: `Think of the reference edge as a boundary line. Anything "below" this line (in the direction of the normal) is inside. Anything "above" it is outside. We need to filter out any candidate points that are floating above this boundary.`,
            desc: `The <b style="color:#ff4d6d">red zone</b> is "above" the reference edge.<br>Any point in this zone is not touching the reference face and must be discarded.`,
            dur: 1000, enter(t) { S.showDepthShade = eO(t); S.showRefNorm = 1; }
          },
          {
            title: `${S_()} â€” The Depth Check`,
            say: `We measure the depth of each point using the dot product giving us a single number. Positive depth means the point is inside or on the boundary â€” we keep it! Negative depth means it is outside â€” we discard it.`,
            desc: `<code>depth = dot(point, refNormal) âˆ’ refDist</code><br>if depth â‰¥ 0 â†’ <b style="color:#3ddc84">KEEP (contacting)</b><br>if depth < 0 â†’ <b style="color:#ff4d6d">DISCARD (no contact)</b>`,
            dur: 1000, enter(t) { S.showDepth0 = eO(t); }
          }
        );

        if (candidatePoints.length >= 2) {
          steps.push({
            title: `${S_()} â€” Measure Depth of Candidate 2`,
            say: `Now we measure the depth of the second candidate point, using the same formula. Is it inside the reference boundary?`,
            desc: `Measuring candidate 2: <code>depth = ${depthValues[1] !== undefined ? depthValues[1].toFixed(2) : '?'}</code><br><b style="color:${depthValues[1] !== undefined && depthValues[1] >= 0 ? '#3ddc84' : '#ff4d6d'}">${depthValues[1] !== undefined ? depthValues[1] >= 0 ? 'depth â‰¥ 0  â†’  KEEP âœ“' : 'depth < 0  â†’  DISCARD âœ—' : ''}</b>`,
            dur: 1050, enter(t) { S.showDepth1 = eO(t); }
          });
        }

        steps.push({
          title: `${S_()} â€” Keep Only Valid Contact Points`,
          say: `We now keep only the points whose depth is zero or positive â€” the ones that are inside the reference boundary. These are the valid contact points. ${contactPoints.length === 0 ? 'In this case no points survived â€” there is no contact.' : contactPoints.length === 1 ? 'One point survived â€” this is a single contact point.' : 'Two points survived â€” these form the final contact edge.'}`,
          desc: `<code>if (depth â‰¥ 0) â†’ keep the point</code><br><b style="color:#ffd166">${contactPoints.length} valid contact point${contactPoints.length !== 1 ? 's' : ''} survived.</b>`,
          dur: 1000, enter(t) { S.showKept = eO(t); }
        });
      }

      // â”€â”€ FINAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      steps.push({
        title: `ğŸ‰ ${S_()} â€” Final Result!`,
        say: `And there it is â€” the final answer shown in yellow. ${contactPoints.length === 2 ? 'We have two contact points forming the final clipped contact edge. These are the actual points where the two edges touch or intersect.' : contactPoints.length === 1 ? 'We have one contact point â€” the edges touch at a single location.' : 'There are no contact points â€” the edges do not actually intersect within the boundary.'}`,
        desc: `<b style="color:#ffd166">Yellow = final clipped edge</b> â€” the true intersection region of the two edges!`,
        dur: 1100, enter(t) { S.final = eO(t); }
      });

      steps.push({
        title: `ğŸ‰ ${S_()} â€” Finished!`,
        say: `This concludes the complete Sutherland-Hodgman edge clipping process. Left clip, right clip, depth filter â€” done! We now have the exact points needed to calculate physics impulses and push shapes apart.`,
        desc: `Left clip â†’ Right clip â†’ Depth filter â†’ Result.`,
        dur: 1100, enter(t) { S.final = 1; }
      });

      return steps;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ANIMATION ENGINE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let steps = [], curStep = -1, anim = false, rafID = null, animT = null;

    function runAnim(ts) {
      if (!animT) animT = ts;
      const el = ts - animT;
      const step = steps[curStep];
      const t = Math.min(1, el / step.dur);
      step.enter(eIO(t));
      drawScene();
      if (t < 1) { rafID = requestAnimationFrame(runAnim); }
      else { anim = false; step.enter(1); drawScene(); }
    }

    function startStep(i) {
      if (rafID) cancelAnimationFrame(rafID);
      curStep = i; animT = null; anim = true;
      const step = steps[i];
      document.getElementById('step-title').textContent = step.title;
      document.getElementById('step-desc').innerHTML = step.desc;
      document.getElementById('prog').textContent = `Step ${i + 1} / ${steps.length}`;
      speak(step.say);
      rafID = requestAnimationFrame(runAnim);
    }

    function fullReset() {
      if (rafID) cancelAnimationFrame(rafID);
      speechSynthesis.cancel();
      resetS(); anim = false; curStep = -1; animT = null;
      computeGeo(); steps = buildSteps();
      document.getElementById('step-title').textContent = 'Ready to Start';
      document.getElementById('step-desc').innerHTML = 'Drag the <b style="color:#3ddc84">green</b> or <b style="color:#ff8c42">orange</b> vertices on the canvas, then press <b>Next Step</b> to begin.';
      document.getElementById('prog').textContent = `Step 0 / ${steps.length}`;
      drawScene();
    }

    document.getElementById('btnNext').onclick = () => {
      if (anim) return;
      if (curStep < 0) { computeGeo(); steps = buildSteps(); }
      if (curStep < steps.length - 1) startStep(curStep + 1);
    };
    document.getElementById('btnPrev').onclick = () => {
      if (anim || curStep <= 0) return;
      resetS();
      for (let i = 0; i < curStep - 1; i++) steps[i].enter(1);
      startStep(curStep - 1);
    };
    document.getElementById('btnReset').onclick = fullReset;

    document.getElementById('btnMute').onclick = () => {
      ttsOn = !ttsOn;
      document.getElementById('btnMute').textContent = ttsOn ? 'ğŸ”Š' : 'ğŸ”‡';
      if (!ttsOn && window.speechSynthesis) speechSynthesis.cancel();
    };

    const btnMuteMusic = document.getElementById('btnMuteMusic');
    if (btnMuteMusic) {
      btnMuteMusic.onclick = () => {
        if (window.toggleBgMusicMute) {
          const isMuted = window.toggleBgMusicMute();
          btnMuteMusic.style.opacity = isMuted ? '0.5' : '1';
        }
      };
    }

    let autoOn = false, autoTimer = null;
    function stopAuto() {
      autoOn = false; clearTimeout(autoTimer);
      document.getElementById('btnAuto').textContent = 'â–¶ Auto';
    }

    document.getElementById('btnAuto').onclick = () => {
      if (autoOn) { stopAuto(); return; }
      autoOn = true;
      document.getElementById('btnAuto').textContent = 'â–  Stop';
      async function tick() {
        if (!autoOn) return;
        if (curStep >= steps.length - 1) { stopAuto(); return; }
        startStep(curStep + 1);
        // We need a way to wait for the speech to finish if possible, 
        // but startStep(i) handles speak() internally.
        // For auto-play consistency with other sims, we'll just use a fixed delay after the step starts.
        autoTimer = setTimeout(tick, 3000);
      }
      tick();
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INIT
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    computeGeo();
    steps = buildSteps();
    document.getElementById('prog').textContent = `Step 0 / ${steps.length}`;
    drawScene();
  </script>
  <script src="bg-music.js"></script>
</body>

</html>
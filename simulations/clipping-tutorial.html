<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Edge Clipping â€” Interactive Visual Tutorial</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link
    href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #0b0d12;
      --panel: #141925;
      --border: #232d42;
      --text: #d0d8f0;
      --muted: #5a6480;
      --accent: #3ddc84;
      --red: #ff4d6d;
      --yellow: #ffd166;
      --blue: #4da6ff;
      --purple: #b48eff;
      --orange: #ff8c42;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'DM Sans', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 16px;
      min-height: 100vh;
    }

    h1 {
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: .04em;
      color: var(--accent);
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    /* â”€â”€ TOOLBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .toolbar {
      width: 100%;
      max-width: 850px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .ctrl {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      font-family: 'DM Sans', sans-serif;
      font-size: .85rem;
      font-weight: 600;
      padding: 8px 18px;
      border-radius: 8px;
      cursor: pointer;
      border: 1px solid var(--border);
      background: #181d2a;
      color: var(--text);
      transition: background .15s, transform .1s, opacity .15s;
      white-space: nowrap;
    }

    button:hover:not(:disabled) {
      background: #1e2638;
      transform: translateY(-1px);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      opacity: .35;
      cursor: not-allowed;
    }

    button.primary {
      background: var(--accent);
      color: #0b0d12;
      border-color: var(--accent);
    }

    button.primary:hover:not(:disabled) {
      background: #4fffaa;
    }

    button.danger {
      border-color: var(--red);
      color: var(--red);
    }

    button.warn {
      border-color: var(--yellow);
      color: var(--yellow);
    }

    button.active-auto {
      background: #2a1a20;
      border-color: var(--red);
      color: var(--red);
    }

    #prog {
      font-family: 'JetBrains Mono', monospace;
      font-size: .72rem;
      color: var(--muted);
      white-space: nowrap;
    }

    /* â”€â”€ PROGRESS BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #progress-bar-wrap {
      width: 100%;
      max-width: 850px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
    }

    #progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--blue));
      border-radius: 2px;
      transition: width .4s ease;
      width: 0%;
    }

    /* â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #main {
      width: 100%;
      max-width: 850px;
      display: flex;
      gap: 14px;
      align-items: flex-start;
    }

    #canvas-wrap {
      flex: 1;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: #0d111a;
      position: relative;
    }

    #canvas-wrap canvas {
      display: block;
      width: 100%;
      height: auto;
      cursor: default;
      touch-action: none;
    }

    #canvas-wrap canvas.drag {
      cursor: grabbing;
    }

    /* â”€â”€ INFO PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #info {
      width: 100%;
      max-width: 850px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 18px;
      min-height: 72px;
    }

    #step-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 6px;
      letter-spacing: .02em;
    }

    #step-desc {
      font-size: .875rem;
      line-height: 1.55;
      color: #a0aac8;
    }

    #step-desc code {
      font-family: 'JetBrains Mono', monospace;
      font-size: .8rem;
      background: #1a2035;
      color: var(--blue);
      padding: 1px 5px;
      border-radius: 4px;
    }

    /* â”€â”€ LEGEND â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .legend {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      font-size: .78rem;
      font-weight: 600;
      justify-content: center;
    }

    .legend span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend span::before {
      content: '';
      width: 22px;
      height: 3px;
      border-radius: 2px;
      display: inline-block;
    }

    .lr::before {
      background: #3ddc84;
    }

    .li::before {
      background: #ff8c42;
    }

    .lt::before {
      background: #4da6ff;
    }

    .lp::before {
      background: #b48eff;
      background: repeating-linear-gradient(90deg, #b48eff 0 4px, transparent 4px 8px);
    }

    .lc::before {
      background: #ff4d6d;
    }

    .lf::before {
      background: #ffd166;
    }

    /* â”€â”€ BOTTOM CONTROLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #bottom-controls {
      width: 100%;
      max-width: 850px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }

    #ctrl-toggle {
      padding: 12px 18px;
      cursor: pointer;
      font-size: .85rem;
      font-weight: 600;
      color: var(--muted);
      user-select: none;
      transition: color .15s;
    }

    #ctrl-toggle:hover {
      color: var(--text);
    }

    #ctrl-toggle.open {
      color: var(--accent);
    }

    #ctrl-body {
      display: none;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      padding: 4px 18px 18px;
    }

    #ctrl-body.open {
      display: grid;
    }

    .ctrl-group h4 {
      font-size: .8rem;
      font-weight: 700;
      color: var(--muted);
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: .06em;
    }

    .srow {
      margin-bottom: 8px;
    }

    .srow label {
      font-size: .78rem;
      color: #7a88a8;
      display: block;
      margin-bottom: 3px;
    }

    .srow input[type=range] {
      width: 100%;
      accent-color: var(--accent);
      height: 4px;
    }

    /* â”€â”€ STEP INDICATOR DOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #step-dots {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 850px;
      width: 100%;
    }

    .sdot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border);
      transition: background .3s, transform .3s;
      cursor: pointer;
    }

    .sdot.done {
      background: var(--muted);
    }

    .sdot.active {
      background: var(--accent);
      transform: scale(1.4);
    }

    /* â”€â”€ PHASE BADGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #phase-badge {
      font-family: 'JetBrains Mono', monospace;
      font-size: .7rem;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      padding: 4px 10px;
      border-radius: 5px;
      background: #1a2035;
      color: var(--muted);
      border: 1px solid var(--border);
      transition: background .3s, color .3s, border-color .3s;
    }

    @media (max-width: 600px) {
      #ctrl-body {
        grid-template-columns: 1fr;
      }

      .toolbar {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>

<body>

  <h1>Edge Clipping â€” Interactive Visual Tutorial</h1>

  <!-- PROGRESS BAR -->
  <div id="progress-bar-wrap">
    <div id="progress-bar"></div>
  </div>

  <!-- TOOLBAR -->
  <div class="toolbar">
    <div class="toolbar-group">
      <div class="ctrl">
        <button id="btnPrev" disabled>â† Prev</button>
        <button id="btnNext" class="primary">Next â†’</button>
        <button id="btnAuto">â–¶ Auto</button>
        <button id="btnReset" class="danger">â†º Reset</button>
        <button id="btnMute" class="warn">ğŸ”Š</button>
        <button id="btnMuteMusic">ğŸµ</button>
      </div>
      <div id="prog">Step 0 / â€”</div>
      <div id="phase-badge">Ready</div>
    </div>
  </div>

  <!-- STEP DOTS -->
  <div id="step-dots"></div>

  <!-- CANVAS -->
  <div id="main">
    <div id="canvas-wrap">
      <canvas id="c" width="700" height="460"></canvas>
    </div>
  </div>

  <!-- INFO PANEL -->
  <div id="info">
    <div id="step-title">Ready to Start</div>
    <div id="step-desc">Drag the <b style="color:#3ddc84">green</b> or <b style="color:#ff8c42">orange</b> vertices on
      the canvas to reposition them, then press <b>Next â†’</b> to begin the tutorial. Or expand <b>Edge Controls</b>
      below.</div>
  </div>

  <!-- LEGEND -->
  <div class="legend">
    <span class="lr">Reference Edge</span>
    <span class="li">Incident Edge</span>
    <span class="lt">Tangent</span>
    <span class="lp">Projection</span>
    <span class="lc">Clip Point</span>
    <span class="lf">Final Output</span>
  </div>

  <!-- BOTTOM COLLAPSIBLE SLIDERS -->
  <div id="bottom-controls">
    <div id="ctrl-toggle">â–¶ Edge Controls (expand to adjust positions)</div>
    <div id="ctrl-body">
      <div class="ctrl-group">
        <h4>â— Reference Edge</h4>
        <div class="srow"><label>Ref Vertex 1 â€” X <span id="rv1x-v">143</span></label><input type="range" id="rv1x"
            min="20" max="680" value="143"></div>
        <div class="srow"><label>Ref Vertex 1 â€” Y <span id="rv1y-v">222</span></label><input type="range" id="rv1y"
            min="20" max="440" value="222"></div>
        <div class="srow"><label>Ref Vertex 2 â€” X <span id="rv2x-v">560</span></label><input type="range" id="rv2x"
            min="20" max="680" value="560"></div>
        <div class="srow"><label>Ref Vertex 2 â€” Y <span id="rv2y-v">224</span></label><input type="range" id="rv2y"
            min="20" max="440" value="224"></div>
      </div>
      <div class="ctrl-group">
        <h4>â— Incident Edge</h4>
        <div class="srow"><label>Inc Vertex 1 â€” X <span id="iv1x-v">607</span></label><input type="range" id="iv1x"
            min="20" max="680" value="607"></div>
        <div class="srow"><label>Inc Vertex 1 â€” Y <span id="iv1y-v">84</span></label><input type="range" id="iv1y"
            min="20" max="440" value="84"></div>
        <div class="srow"><label>Inc Vertex 2 â€” X <span id="iv2x-v">70</span></label><input type="range" id="iv2x"
            min="20" max="680" value="70"></div>
        <div class="srow"><label>Inc Vertex 2 â€” Y <span id="iv2y-v">365</span></label><input type="range" id="iv2y"
            min="20" max="440" value="365"></div>
      </div>
    </div>
  </div>

  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANVAS SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CV = document.getElementById('c');
    const cx = CV.getContext('2d');
    const W = 700, H = 460;
    CV.width = W; CV.height = H;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VECTOR MATH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const vm = {
      sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
      add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
      sc: (a, t) => ({ x: a.x * t, y: a.y * t }),
      dot: (a, b) => a.x * b.x + a.y * b.y,
      len: (a) => Math.sqrt(a.x * a.x + a.y * a.y),
      norm: (a) => { const l = Math.sqrt(a.x * a.x + a.y * a.y) || 1; return { x: a.x / l, y: a.y / l }; },
      perp: (a) => ({ x: -a.y, y: a.x }),
      proj: (pt, anc, t) => { const d = vm.dot(vm.sub(pt, anc), t); return vm.add(anc, vm.sc(t, d)); },
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GEOMETRY â€” recomputed live
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let G = {};

    function computeGeo() {
      const g = id => +document.getElementById(id).value;
      const refV1 = { x: g('rv1x'), y: g('rv1y') };
      const refV2 = { x: g('rv2x'), y: g('rv2y') };
      const incV1 = { x: g('iv1x'), y: g('iv1y') };
      const incV2 = { x: g('iv2x'), y: g('iv2y') };

      const tang = vm.norm(vm.sub(refV2, refV1));
      const negT = vm.sc(tang, -1);
      const refNormal = vm.norm({ x: -tang.y, y: tang.x });

      // LEFT clip (anchor=refV1, direction=tang)
      const d0L = vm.dot(vm.sub(incV1, refV1), tang);
      const d1L = vm.dot(vm.sub(incV2, refV1), tang);
      const tL = (d0L - d1L !== 0) ? d0L / (d0L - d1L) : null;
      let leftClipPt = null, leftOut = [];
      if (d0L >= 0 && d1L >= 0) { leftOut = [{ ...incV1 }, { ...incV2 }]; }
      else if (d0L < 0 && d1L < 0) { leftOut = []; }
      else {
        leftClipPt = vm.add(incV1, vm.sc(vm.sub(incV2, incV1), tL));
        if (d0L >= 0) leftOut = [{ ...incV1 }, { ...leftClipPt }];
        else leftOut = [{ ...leftClipPt }, { ...incV2 }];
      }

      // RIGHT clip (anchor=refV2, direction=negT)
      let d0R = null, d1R = null, tR = null, rightClipPt = null, rightOut = [];
      if (leftOut.length === 2) {
        const lo0 = leftOut[0], lo1 = leftOut[1];
        d0R = vm.dot(vm.sub(lo0, refV2), negT);
        d1R = vm.dot(vm.sub(lo1, refV2), negT);
        tR = (d0R - d1R !== 0) ? d0R / (d0R - d1R) : null;
        if (d0R >= 0 && d1R >= 0) { rightOut = [{ ...lo0 }, { ...lo1 }]; }
        else if (d0R < 0 && d1R < 0) { rightOut = []; }
        else {
          rightClipPt = vm.add(lo0, vm.sc(vm.sub(lo1, lo0), tR));
          if (d0R >= 0) rightOut = [{ ...lo0 }, { ...rightClipPt }];
          else rightOut = [{ ...rightClipPt }, { ...lo1 }];
        }
      }

      // DEPTH FILTER
      const refDist = vm.dot(refV1, refNormal);
      const candidatePoints = [...rightOut];
      const contactPoints = [], depthValues = [];
      for (const p of candidatePoints) {
        const d = vm.dot(p, refNormal) - refDist;
        depthValues.push(d);
        if (d >= 0) contactPoints.push(p);
      }

      G = {
        refV1, refV2, incV1, incV2, tang, negT, refNormal, refDist,
        d0L, d1L, tL, leftClipPt, leftOut,
        d0R, d1R, tR, rightClipPt, rightOut,
        candidatePoints, depthValues, contactPoints
      };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EASING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const eO = t => 1 - (1 - t) * (1 - t);
    const eIO = t => t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DRAW PRIMITIVES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function dDot(p, r, col, a = 1) {
      if (!p) return;
      cx.save(); cx.globalAlpha = a; cx.fillStyle = col;
      cx.beginPath(); cx.arc(p.x, p.y, r, 0, Math.PI * 2); cx.fill(); cx.restore();
    }
    function dLine(a, b, col, w = 2, dash = [], al = 1) {
      if (!a || !b) return;
      cx.save(); cx.globalAlpha = al; cx.strokeStyle = col; cx.lineWidth = w;
      cx.setLineDash(dash); cx.lineCap = 'round';
      cx.beginPath(); cx.moveTo(a.x, a.y); cx.lineTo(b.x, b.y); cx.stroke(); cx.restore();
    }
    function dArrow(f, t, col, w = 2, al = 1, hs = 10) {
      if (!f || !t) return;
      const d = Math.hypot(t.x - f.x, t.y - f.y); if (d < 2) return;
      cx.save(); cx.globalAlpha = al; cx.strokeStyle = col; cx.fillStyle = col; cx.lineWidth = w; cx.lineCap = 'round';
      cx.beginPath(); cx.moveTo(f.x, f.y); cx.lineTo(t.x, t.y); cx.stroke();
      const a = Math.atan2(t.y - f.y, t.x - f.x);
      cx.beginPath(); cx.moveTo(t.x, t.y);
      cx.lineTo(t.x - hs * Math.cos(a - .4), t.y - hs * Math.sin(a - .4));
      cx.lineTo(t.x - hs * Math.cos(a + .4), t.y - hs * Math.sin(a + .4));
      cx.closePath(); cx.fill(); cx.restore();
    }
    function pill(txt, p, bg, fg = '#fff', al = 1) {
      if (!p) return;
      cx.save();
      cx.shadowColor = 'transparent'; cx.shadowBlur = 0;
      cx.font = 'bold 11px "JetBrains Mono",monospace';
      cx.textAlign = 'left'; cx.textBaseline = 'alphabetic';
      const tw = cx.measureText(txt).width;
      const pad = 6, h = 20, r = 5;
      const bx = p.x - pad, by = p.y - 15, bw = tw + pad * 2, bh = h;
      cx.globalAlpha = al; cx.fillStyle = bg;
      cx.beginPath();
      if (cx.roundRect) { cx.roundRect(bx, by, bw, bh, r); }
      else {
        cx.moveTo(bx + r, by); cx.lineTo(bx + bw - r, by);
        cx.arcTo(bx + bw, by, bx + bw, by + r, r); cx.lineTo(bx + bw, by + bh - r);
        cx.arcTo(bx + bw, by + bh, bx + bw - r, by + bh, r); cx.lineTo(bx + r, by + bh);
        cx.arcTo(bx, by + bh, bx, by + bh - r, r); cx.lineTo(bx, by + r);
        cx.arcTo(bx, by, bx + r, by, r); cx.closePath();
      }
      cx.fill();
      cx.globalAlpha = 1; cx.fillStyle = fg;
      cx.fillText(txt, p.x, p.y - 1);
      cx.restore();
    }
    function dShadeHalfPlane(p, n, col, al) {
      const w = 2000, h = 2000;
      cx.save(); cx.translate(p.x, p.y);
      const ang = Math.atan2(n.y, n.x); cx.rotate(ang);
      cx.globalAlpha = al * .2; cx.fillStyle = col;
      cx.fillRect(0, -h / 2, w, h); cx.restore();
      const edgeDir = { x: -n.y, y: n.x };
      const p1 = vm.add(p, vm.sc(edgeDir, -1000));
      const p2 = vm.add(p, vm.sc(edgeDir, 1000));
      dLine(p1, p2, col, 1.5, [6, 4], al * .6);
    }

    // Draw a two-line zone label at a fixed canvas position
    function zoneLabel(outsideTxt, insideTxt, outsideAnchor, insideAnchor, col, al) {
      // outsideAnchor / insideAnchor: {x,y} in canvas coords â€” fixed corners
      function banner(txt, anchor, bg, fg, a) {
        cx.save();
        cx.font = 'bold 11px "JetBrains Mono",monospace';
        cx.textAlign = 'left'; cx.textBaseline = 'alphabetic';
        const tw = cx.measureText(txt).width;
        const pad = 7, h = 22, r = 5;
        const bx = anchor.x, by = anchor.y - 16, bw = tw + pad * 2, bh = h;
        cx.globalAlpha = a;
        cx.fillStyle = bg;
        cx.beginPath();
        if (cx.roundRect) { cx.roundRect(bx, by, bw, bh, r); }
        else {
          cx.moveTo(bx + r, by); cx.lineTo(bx + bw - r, by);
          cx.arcTo(bx + bw, by, bx + bw, by + r, r); cx.lineTo(bx + bw, by + bh - r);
          cx.arcTo(bx + bw, by + bh, bx + bw - r, by + bh, r); cx.lineTo(bx + r, by + bh);
          cx.arcTo(bx, by + bh, bx, by + bh - r, r); cx.lineTo(bx, by + r);
          cx.arcTo(bx, by, bx + r, by, r); cx.closePath();
        }
        cx.fill();
        cx.globalAlpha = 1; cx.fillStyle = fg;
        cx.fillText(txt, anchor.x + pad, anchor.y - 1);
        cx.restore();
      }
      banner(outsideTxt, outsideAnchor, col, '#fff', al);
      banner(insideTxt, insideAnchor, '#1e3a28', '#3ddc84', al);
    }

    function dShadeLeft(al) {
      dShadeHalfPlane(G.refV1, G.negT, '#ff4d6d', al);
      // Outside = left side (xâ‰ˆ0), Inside = right side
      zoneLabel('âœ— OUTSIDE', 'âœ“ INSIDE',
        { x: 6, y: 18 },   // top-left corner
        { x: W / 2 + 20, y: 18 }, // top-center-right
        '#ff4d6d', al);
    }
    function dShadeRight(al) {
      dShadeHalfPlane(G.refV2, G.tang, '#ff4d6d', al);
      // Outside = right side, Inside = left side
      zoneLabel('âœ— OUTSIDE', 'âœ“ INSIDE',
        { x: W - 130, y: 18 },  // top-right corner
        { x: 20, y: 18 },  // top-left
        '#ff4d6d', al);
    }
    function dShadeAbove(al) {
      const outN = vm.sc(G.refNormal, -1);
      dShadeHalfPlane(G.refV1, outN, '#ff4d6d', al);
      // Outside = above ref edge (small y), Inside = below (large y)
      // Determine which half is "above" by checking where outN points
      const aboveIsTop = outN.y < 0;
      const outsideY = aboveIsTop ? 18 : H - 8;
      const insideY = aboveIsTop ? H - 8 : 18;
      zoneLabel('âœ— OUTSIDE (above edge)', 'âœ“ INSIDE (below edge)',
        { x: W / 2 - 100, y: outsideY },
        { x: W / 2 - 80, y: insideY },
        '#ff4d6d', al);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANIMATED STATE  â€” one flat object, all keys 0â†’1
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const STATE_KEYS = [
      'ref', 'inc',
      'shL', 'tang',
      'tI1', 'tI2',
      'pI1', 'd0', 'pI2', 'd1',
      'pf',
      'showFullVec', 'tFrac',
      'cpL', 'lOut',
      'newInc',
      'shR', 'negT',
      'tI1R', 'tI2R',
      'pI1R', 'd0R', 'pI2R', 'd1R',
      'pfR',
      'pfR',
      'showFullVecR', 'tFracR',
      'cpR',
      'showCandidates',
      'showRefNorm',
      'showDepthShade',
      'showDepth0', 'showDepth1',
      'showKept',
      'final',
    ];

    let S = {};
    function resetS() {
      S = {};
      for (const k of STATE_KEYS) S[k] = 0;
    }
    resetS();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAIN DRAW SCENE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function drawScene() {
      cx.clearRect(0, 0, W, H);
      // grid
      cx.save(); cx.strokeStyle = '#141925'; cx.lineWidth = 1;
      for (let x = 0; x < W; x += 40) { cx.beginPath(); cx.moveTo(x, 0); cx.lineTo(x, H); cx.stroke(); }
      for (let y = 0; y < H; y += 40) { cx.beginPath(); cx.moveTo(0, y); cx.lineTo(W, y); cx.stroke(); }
      cx.restore();

      const { refV1, refV2, incV1, incV2, tang, negT, refNormal,
        d0L, d1L, tL, leftClipPt, leftOut,
        d0R, d1R, tR, rightClipPt, rightOut,
        candidatePoints, depthValues, contactPoints } = G;

      // shades
      if (S.shL > 0) dShadeLeft(S.shL);
      if (S.shR > 0) dShadeRight(S.shR);
      if (S.showDepthShade > 0) dShadeAbove(S.showDepthShade);

      // incident edge
      if (S.inc > 0) {
        dLine(incV1, incV2, '#ff8c42', 2.5, [], S.inc);
        dDot(incV1, 7, '#ff8c42', S.inc); dDot(incV2, 7, '#ff8c42', S.inc);
        pill('IncV1', { x: incV1.x + 10, y: incV1.y - 10 }, '#ff8c42', '#fff', S.inc);
        pill('IncV2', { x: incV2.x + 10, y: incV2.y + 18 }, '#ff8c42', '#fff', S.inc);
      }

      // reference edge
      if (S.ref > 0) {
        dLine(refV1, refV2, '#3ddc84', 3, [], S.ref);
        dDot(refV1, 7, '#3ddc84', S.ref); dDot(refV2, 7, '#3ddc84', S.ref);
        pill('RefV1', { x: refV1.x - 40, y: refV1.y - 14 }, '#3ddc84', '#fff', S.ref);
        pill('RefV2', { x: refV2.x + 10, y: refV2.y - 14 }, '#3ddc84', '#fff', S.ref);
      }

      // tangent arrow
      if (S.tang > 0) {
        dArrow(refV1, vm.add(refV1, vm.sc(tang, 85)), '#4da6ff', 2.5, S.tang, 10);
        pill('TÌ‚  (tangent)', { x: refV1.x + 18, y: refV1.y - 18 }, '#4da6ff', '#fff', S.tang);
      }

      // vectors RefV1 â†’ inc verts
      if (S.tI1 > 0) dArrow(refV1, incV1, '#b48eff', 1.8, S.tI1, 8);
      if (S.tI2 > 0) dArrow(refV1, incV2, '#b48eff', 1.8, S.tI2, 8);

      // projections + d labels (left)
      if (S.pI1 > 0) { const p = vm.proj(incV1, refV1, tang); dLine(incV1, p, '#b48eff', 1.5, [4, 4], S.pI1); dDot(p, 5, '#b48eff', S.pI1); }
      if (S.d0 > 0) {
        const p = vm.proj(incV1, refV1, tang);
        const sg = d0L >= 0 ? '+' : '';
        pill(`d0 = ${sg}${d0L.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d0L >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d0);
      }
      if (S.pI2 > 0) { const p = vm.proj(incV2, refV1, tang); dLine(incV2, p, '#b48eff', 1.5, [4, 4], S.pI2); dDot(p, 5, '#b48eff', S.pI2); }
      if (S.d1 > 0) {
        const p = vm.proj(incV2, refV1, tang);
        const sg = d1L >= 0 ? '+' : '';
        pill(`d1 = ${sg}${d1L.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d1L >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d1);
      }

      // pass/fail rings (left)
      if (S.pf > 0) {
        const c0 = d0L >= 0 ? '#3ddc84' : '#ff4d6d', c1 = d1L >= 0 ? '#3ddc84' : '#ff4d6d';
        dDot(incV1, 16, c0, S.pf * .22); dDot(incV2, 16, c1, S.pf * .22);
        cx.save(); cx.globalAlpha = S.pf; cx.textAlign = 'center'; cx.textBaseline = 'middle';
        cx.font = 'bold 14px sans-serif';
        cx.fillStyle = c0; cx.fillText(d0L >= 0 ? 'âœ“' : 'âœ—', incV1.x, incV1.y);
        cx.fillStyle = c1; cx.fillText(d1L >= 0 ? 'âœ“' : 'âœ—', incV2.x, incV2.y);
        cx.restore();
      }

      // t animation (left)
      if (S.showFullVec > 0) {
        dLine(incV1, incV2, '#00d4ff', 1.5, [], S.showFullVec * .45);
        dArrow(incV1, incV2, '#00d4ff', 1, S.showFullVec * .4, 7);
        pill('IncV1 â†’ IncV2 (full edge)', { x: incV1.x + 10, y: incV1.y + 18 }, '#00d4ff', '#0b0d12', S.showFullVec * .8);
      }
      if (S.tFrac > 0 && tL !== null) {
        const end = vm.add(incV1, vm.sc(vm.sub(incV2, incV1), S.tFrac * tL));
        dArrow(incV1, end, '#00d4ff', 3, Math.min(1, S.tFrac * 3), 11);
        const tv = (S.tFrac * tL).toFixed(3);
        pill(`t = ${tv}  â†’  growing...`, { x: incV1.x + 12, y: incV1.y - 26 }, '#00d4ff', '#0b0d12', Math.min(1, S.tFrac * 3));
      }

      // left clip point
      if (S.cpL > 0 && leftClipPt) {
        dDot(leftClipPt, 9, '#ff4d6d', S.cpL);
        pill('Clip Point (Left)', { x: leftClipPt.x + 10, y: leftClipPt.y + 20 }, '#ff4d6d', '#fff', S.cpL);
      }

      // left clip output
      if (S.lOut > 0 && leftOut.length === 2) {
        dLine(leftOut[0], leftOut[1], '#ff4d6d', 2.5, [8, 5], S.lOut);
        dDot(leftOut[0], 7, '#ff4d6d', S.lOut); dDot(leftOut[1], 7, '#ff4d6d', S.lOut);
      }

      // â”€â”€ RIGHT CLIP PHASE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (S.newInc > 0 && leftOut.length === 2) {
        dLine(leftOut[0], leftOut[1], '#ff8c42', 3, [], S.newInc);
        dDot(leftOut[0], 8, '#ff8c42', S.newInc); dDot(leftOut[1], 8, '#ff8c42', S.newInc);
        pill('NewV1', { x: leftOut[0].x + 10, y: leftOut[0].y + 20 }, '#ff8c42', '#fff', S.newInc);
        pill('NewV2', { x: leftOut[1].x + 10, y: leftOut[1].y - 14 }, '#ff8c42', '#fff', S.newInc);
      }
      if (S.negT > 0) {
        dArrow(refV2, vm.add(refV2, vm.sc(negT, 85)), '#4da6ff', 2.5, S.negT, 10);
        pill('âˆ’TÌ‚  (reversed)', { x: refV2.x - 100, y: refV2.y - 18 }, '#4da6ff', '#fff', S.negT);
      }
      if (S.tI1R > 0 && leftOut.length === 2) dArrow(refV2, leftOut[0], '#b48eff', 1.8, S.tI1R, 8);
      if (S.tI2R > 0 && leftOut.length === 2) dArrow(refV2, leftOut[1], '#b48eff', 1.8, S.tI2R, 8);
      if (S.pI1R > 0 && leftOut.length === 2) { const p = vm.proj(leftOut[0], refV2, negT); dLine(leftOut[0], p, '#b48eff', 1.5, [4, 4], S.pI1R); dDot(p, 5, '#b48eff', S.pI1R); }
      if (S.d0R > 0 && d0R !== null) {
        const p = vm.proj(leftOut[0], refV2, negT);
        pill(`d0 = ${d0R >= 0 ? '+' : ''}${d0R.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d0R >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d0R);
      }
      if (S.pI2R > 0 && leftOut.length === 2) { const p = vm.proj(leftOut[1], refV2, negT); dLine(leftOut[1], p, '#b48eff', 1.5, [4, 4], S.pI2R); dDot(p, 5, '#b48eff', S.pI2R); }
      if (S.d1R > 0 && d1R !== null) {
        const p = vm.proj(leftOut[1], refV2, negT);
        pill(`d1 = ${d1R >= 0 ? '+' : ''}${d1R.toFixed(1)}`, { x: p.x + 6, y: p.y + 20 }, d1R >= 0 ? '#3ddc84' : '#ff4d6d', '#fff', S.d1R);
      }
      if (S.pfR > 0 && leftOut.length === 2) {
        const c0 = d0R >= 0 ? '#3ddc84' : '#ff4d6d', c1 = d1R >= 0 ? '#3ddc84' : '#ff4d6d';
        dDot(leftOut[0], 16, c0, S.pfR * .22); dDot(leftOut[1], 16, c1, S.pfR * .22);
        cx.save(); cx.globalAlpha = S.pfR; cx.textAlign = 'center'; cx.textBaseline = 'middle';
        cx.font = 'bold 14px sans-serif';
        cx.fillStyle = c0; cx.fillText(d0R >= 0 ? 'âœ“' : 'âœ—', leftOut[0].x, leftOut[0].y);
        cx.fillStyle = c1; cx.fillText(d1R >= 0 ? 'âœ“' : 'âœ—', leftOut[1].x, leftOut[1].y);
        cx.restore();
      }
      // t animation RIGHT
      if (S.showFullVecR > 0 && leftOut.length === 2) {
        dLine(leftOut[0], leftOut[1], '#00d4ff', 1.5, [], S.showFullVecR * .45);
        dArrow(leftOut[0], leftOut[1], '#00d4ff', 1, S.showFullVecR * .4, 7);
        pill('NewV1 â†’ NewV2 (full edge)', { x: leftOut[0].x + 10, y: leftOut[0].y - 26 }, '#00d4ff', '#0b0d12', S.showFullVecR * .8);
      }
      if (S.tFracR > 0 && tR !== null && leftOut.length === 2) {
        const lo0 = leftOut[0], lo1 = leftOut[1];
        const end = vm.add(lo0, vm.sc(vm.sub(lo1, lo0), S.tFracR * tR));
        dArrow(lo0, end, '#00d4ff', 3, Math.min(1, S.tFracR * 3), 11);
        pill(`t = ${(S.tFracR * tR).toFixed(3)}  â†’  growing...`, { x: lo0.x + 12, y: lo0.y - 26 }, '#00d4ff', '#0b0d12', Math.min(1, S.tFracR * 3));
      }
      if (S.cpR > 0 && rightClipPt) {
        dDot(rightClipPt, 9, '#ff4d6d', S.cpR);
        pill('Clip Point (Right)', { x: rightClipPt.x + 10, y: rightClipPt.y + 20 }, '#ff4d6d', '#fff', S.cpR);
      }

      // â”€â”€ DEPTH FILTER PHASE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (S.showCandidates > 0) {
        for (let i = 0; i < candidatePoints.length; i++) {
          const p = candidatePoints[i];
          dDot(p, 10, '#b48eff', S.showCandidates);
          pill(`Candidate ${i + 1}`, { x: p.x + 12, y: p.y - 10 }, '#b48eff', '#fff', S.showCandidates);
        }
        if (rightOut.length === 2) dLine(rightOut[0], rightOut[1], '#b48eff', 2, [4, 4], S.showCandidates * .7);
      }

      if (S.showRefNorm > 0) {
        const mx = (refV1.x + refV2.x) * .5, my = (refV1.y + refV2.y) * .5;
        const mid = { x: mx, y: my };
        const end = vm.add(mid, vm.sc(refNormal, 50));
        dArrow(mid, end, '#ffd166', 3, S.showRefNorm, 12);
        pill('n (normal)', { x: end.x, y: end.y + 20 }, '#ffd166', '#0b0d12', S.showRefNorm);
      }

      if (S.showDepth0 > 0 && candidatePoints.length > 0) {
        const p = candidatePoints[0], d = depthValues[0];
        const refY = refV1.y;
        dLine(p, { x: p.x, y: refY }, '#ffd166', 1.5, [4, 4], S.showDepth0);
        dDot({ x: p.x, y: refY }, 5, '#ffd166', S.showDepth0);
        const sign = d <= 0 ? 'â‰¤ 0' : '> 0';
        const col = d <= 0 ? '#3ddc84' : '#ff4d6d';
        pill(`depth = ${d.toFixed(1)} (${sign})`, { x: p.x + 8, y: (p.y + refY) / 2 }, col, '#fff', S.showDepth0);
      }
      if (S.showDepth1 > 0 && candidatePoints.length > 1) {
        const p = candidatePoints[1], d = depthValues[1];
        const refY = refV1.y;
        dLine(p, { x: p.x, y: refY }, '#ffd166', 1.5, [4, 4], S.showDepth1);
        dDot({ x: p.x, y: refY }, 5, '#ffd166', S.showDepth1);
        const sign = d <= 0 ? 'â‰¤ 0' : '> 0';
        const col = d <= 0 ? '#3ddc84' : '#ff4d6d';
        pill(`depth = ${d.toFixed(1)} (${sign})`, { x: p.x + 8, y: (p.y + refY) / 2 }, col, '#fff', S.showDepth1);
      }

      if (S.showKept > 0) {
        for (const p of contactPoints) {
          dDot(p, 12, '#ffd166', S.showKept);
          cx.save(); cx.globalAlpha = S.showKept; cx.fillStyle = '#ffd166';
          cx.font = 'bold 13px sans-serif'; cx.textAlign = 'center'; cx.textBaseline = 'middle';
          cx.fillText('âœ“', p.x, p.y); cx.restore();
        }
      }

      // FINAL
      if (S.final > 0 && contactPoints.length === 2) {
        cx.save(); cx.globalAlpha = S.final * .2; cx.strokeStyle = '#ffd166'; cx.lineWidth = 16; cx.lineCap = 'round';
        cx.beginPath(); cx.moveTo(contactPoints[0].x, contactPoints[0].y);
        cx.lineTo(contactPoints[1].x, contactPoints[1].y); cx.stroke(); cx.restore();
        dLine(contactPoints[0], contactPoints[1], '#ffd166', 4, [], S.final);
        dDot(contactPoints[0], 9, '#ffd166', S.final); dDot(contactPoints[1], 9, '#ffd166', S.final);
        const mx = (contactPoints[0].x + contactPoints[1].x) / 2;
        const my = (contactPoints[0].y + contactPoints[1].y) / 2;
        pill('âœ“  Final Contact Edge', { x: mx - 66, y: my - 18 }, '#ffd166', '#0b0d12', S.final);
      } else if (S.final > 0 && contactPoints.length === 1) {
        dDot(contactPoints[0], 9, '#ffd166', S.final);
        pill('âœ“  Single Contact Point', { x: contactPoints[0].x + 10, y: contactPoints[0].y - 18 }, '#ffd166', '#0b0d12', S.final);
      } else if (S.final > 0 && contactPoints.length === 0) {
        pill('No Contact â€” edges do not intersect', { x: W / 2 - 110, y: H / 2 }, '#ff4d6d', '#fff', S.final);
      }

      // drag handles (ready screen)
      if (curStep < 0) {
        dLine(G.refV1, G.refV2, '#3ddc84', 2, [], 0.6);
        dLine(G.incV1, G.incV2, '#ff8c42', 2, [], 0.6);
        const pts = [
          { p: G.refV1, c: '#3ddc84' }, { p: G.refV2, c: '#3ddc84' },
          { p: G.incV1, c: '#ff8c42' }, { p: G.incV2, c: '#ff8c42' }
        ];
        for (const { p, c } of pts) {
          cx.save(); cx.globalAlpha = .55; cx.strokeStyle = c; cx.lineWidth = 2; cx.setLineDash([3, 3]);
          cx.beginPath(); cx.arc(p.x, p.y, 17, 0, Math.PI * 2); cx.stroke(); cx.restore();
          dDot(p, 7, c, .95);
        }
        pill('RefV1', { x: G.refV1.x - 40, y: G.refV1.y - 14 }, '#3ddc84', '#fff', .85);
        pill('RefV2', { x: G.refV2.x + 10, y: G.refV2.y - 14 }, '#3ddc84', '#fff', .85);
        pill('IncV1', { x: G.incV1.x + 10, y: G.incV1.y - 14 }, '#ff8c42', '#fff', .85);
        pill('IncV2', { x: G.incV2.x + 10, y: G.incV2.y + 18 }, '#ff8c42', '#fff', .85);
        cx.save(); cx.globalAlpha = .45; cx.fillStyle = '#5a6480';
        cx.font = 'bold 11px "JetBrains Mono",monospace'; cx.textAlign = 'center';
        cx.fillText('â† drag vertices to reposition â†’', W / 2, H - 12); cx.restore();
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DRAG ON CANVAS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let dragV = null;
    const dragMap = [
      { get: () => G.refV1, sx: 'rv1x', sy: 'rv1y' },
      { get: () => G.refV2, sx: 'rv2x', sy: 'rv2y' },
      { get: () => G.incV1, sx: 'iv1x', sy: 'iv1y' },
      { get: () => G.incV2, sx: 'iv2x', sy: 'iv2y' },
    ];
    function cXY(e) {
      const r = CV.getBoundingClientRect();
      const src = e.touches ? e.touches[0] : e;
      return { x: (src.clientX - r.left) * W / r.width, y: (src.clientY - r.top) * H / r.height };
    }
    CV.addEventListener('mousedown', e => {
      if (curStep >= 0) return;
      const { x, y } = cXY(e);
      let found = null;
      for (const m of dragMap) { const p = m.get(); if (Math.hypot(p.x - x, p.y - y) < 30) { found = m; break; } }
      if (found) { dragV = found; CV.classList.add('drag'); }
    });
    CV.addEventListener('mousemove', e => {
      if (!dragV) return;
      const { x, y } = cXY(e);
      const sx = document.getElementById(dragV.sx);
      sx.value = Math.min(+sx.max, Math.max(+sx.min, Math.round(x)));
      document.getElementById(dragV.sx + '-v').textContent = sx.value;
      const sy = document.getElementById(dragV.sy);
      sy.value = Math.min(+sy.max, Math.max(+sy.min, Math.round(y)));
      document.getElementById(dragV.sy + '-v').textContent = sy.value;
      computeGeo(); drawScene();
    });
    CV.addEventListener('mouseup', () => { dragV = null; CV.classList.remove('drag'); });
    CV.addEventListener('mouseleave', () => { dragV = null; CV.classList.remove('drag'); });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SLIDERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ['rv1x', 'rv1y', 'rv2x', 'rv2y', 'iv1x', 'iv1y', 'iv2x', 'iv2y'].forEach(id => {
      const el = document.getElementById(id);
      const vl = document.getElementById(id + '-v');
      vl.textContent = el.value;
      el.addEventListener('input', () => { vl.textContent = el.value; computeGeo(); if (curStep < 0) drawScene(); });
    });

    document.getElementById('ctrl-toggle').addEventListener('click', () => {
      const tog = document.getElementById('ctrl-toggle');
      const bod = document.getElementById('ctrl-body');
      const open = bod.classList.toggle('open');
      tog.classList.toggle('open', open);
      tog.textContent = open ? 'â–¼ Edge Controls (collapse)' : 'â–¶ Edge Controls (expand to adjust positions)';
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let ttsOn = true;
    let chosenVoice = null;

    const VOICE_PRIORITY = [
      'Microsoft Guy Online (Natural) - English (United States)',
      'Google US English',
      'Samantha',
      'Google UK English Male',
      'Daniel',
      'Microsoft Zira Desktop - English (United States)'
    ];

    function pickVoice() {
      const voices = speechSynthesis.getVoices();
      if (!voices.length) return;
      for (const name of VOICE_PRIORITY) {
        const found = voices.find(v => v.name.includes(name) || v.name === name);
        if (found) { chosenVoice = found; return; }
      }
      const enUS = voices.find(v => v.lang === 'en-US');
      if (enUS) { chosenVoice = enUS; return; }
      const en = voices.find(v => v.lang.startsWith('en'));
      if (en) { chosenVoice = en; }
    }
    if (typeof speechSynthesis !== 'undefined') {
      speechSynthesis.onvoiceschanged = pickVoice;
      pickVoice();
      setTimeout(pickVoice, 200);
      setTimeout(pickVoice, 1000);
    }

    function speak(txt) {
      const descBox = document.getElementById('step-desc');
      if (descBox && txt) descBox.innerHTML = txt;
      if (!ttsOn || !window.speechSynthesis) return;
      speechSynthesis.cancel();
      if (!chosenVoice) pickVoice();
      const clean = txt.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
      const u = new SpeechSynthesisUtterance(clean);
      if (chosenVoice) u.voice = chosenVoice;
      u.lang = 'en-US'; u.rate = 1.0; u.pitch = 1.0;
      if (window.bgMusicDuck) window.bgMusicDuck();
      u.onend = () => { if (window.bgMusicRestore) window.bgMusicRestore(); };
      u.onerror = () => { if (window.bgMusicRestore) window.bgMusicRestore(); };
      speechSynthesis.speak(u);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP BUILDER
    // Returns an array where each step has:
    //   .title  .desc  .say  .dur  .targets  .phase
    //
    // FIX: Instead of `enter(t)` functions that mutate S in complex
    // overlapping ways, each step declares `targets` â€” a dict of
    // STATE_KEYS â†’ final values (0 or 1). On playback we lerp from
    // the PREVIOUS snapshot to these targets. On Prev we reconstruct
    // the snapshot by replaying targets[0..i-1] instantaneously, then
    // animate from that into targets[i]. This makes Prev perfectly
    // reliable regardless of how many steps there are.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function buildSteps() {
      const { d0L, d1L, tL, leftClipPt, leftOut, d0R, d1R, tR, rightClipPt, rightOut,
        candidatePoints, depthValues, contactPoints } = G;

      const crossesL = (d0L >= 0) !== (d1L >= 0);
      const crossesR = d0R !== null && ((d0R >= 0) !== (d1R >= 0));
      const iv1in = d0L >= 0, iv2in = d1L >= 0;

      // Shorthand helpers
      const lo0in = d0R >= 0, lo1in = d1R >= 0;

      // Each step: title, say, desc, dur, phase, targets (partial â€” keys not listed keep their value from previous step)
      const steps = [];

      function addStep(s) { steps.push(s); }

      // STEP 1
      addStep({
        title: 'Step 1 â€” The Two Edges',
        phase: 'Introduction',
        say: `Let us get started. Here we have two edges. The green one is the Reference Edge â€” the face being hit first. The orange one is the Incident Edge â€” the edge crashing into it.`,
        desc: `<b style="color:#3ddc84">Green = Reference Edge</b> â€” the face with least penetration.<br><b style="color:#ff8c42">Orange = Incident Edge</b> â€” the edge crashing into the reference face.`,
        dur: 1100,
        targets: { ref: 1, inc: 1 }
      });

      // STEP 2
      addStep({
        title: 'Step 2 â€” The Tangent Vector',
        phase: 'Left Clip',
        say: `We compute the tangent vector of the reference edge â€” a normalized direction from Reference Vertex 1 toward Reference Vertex 2. We call this T-hat.`,
        desc: `<code>TÌ‚ = normalize(RefV2 âˆ’ RefV1)</code><br>Unit vector pointing along the reference edge â€” the "forward" direction.`,
        dur: 950,
        targets: { tang: 1 }
      });

      // STEP 3
      addStep({
        title: 'Step 3 â€” Vectors to Incident Vertices',
        phase: 'Left Clip',
        say: `Now we draw vectors from Reference Vertex 1 to each endpoint of the incident edge. These help us measure how far along the boundary each point is.`,
        desc: `Arrows from <b style="color:#3ddc84">RefV1</b> â†’ <b style="color:#ff8c42">IncV1</b> and <b style="color:#ff8c42">IncV2</b>.<br>These measure each vertex against the left boundary anchor.`,
        dur: 950,
        targets: { tI1: 1, tI2: 1 }
      });

      // STEP 4
      addStep({
        title: 'Step 4 â€” Measure IncV1: dot product d0',
        phase: 'Left Clip',
        say: `We project Incident Vertex 1 onto the tangent. The result, d0, is ${d0L.toFixed(1)}. ${d0L >= 0 ? 'Positive â€” it is inside the left boundary.' : 'Negative â€” it is outside the left boundary.'}`,
        desc: `<code>d0 = dot(IncV1 âˆ’ RefV1, TÌ‚) = ${d0L.toFixed(1)}</code><br><b style="color:${d0L >= 0 ? '#3ddc84' : '#ff4d6d'}">${d0L >= 0 ? 'd0 > 0  â†’  IncV1 is INSIDE âœ“' : 'd0 < 0  â†’  IncV1 is OUTSIDE âœ—'}</b>`,
        dur: 1100,
        targets: { pI1: 1, d0: 1 }
      });

      // STEP 5
      addStep({
        title: 'Step 5 â€” Measure IncV2: dot product d1',
        phase: 'Left Clip',
        say: `Same process for Incident Vertex 2. d1 equals ${d1L.toFixed(1)}. ${d1L >= 0 ? 'Positive â€” inside.' : 'Negative â€” outside.'}`,
        desc: `<code>d1 = dot(IncV2 âˆ’ RefV1, TÌ‚) = ${d1L.toFixed(1)}</code><br><b style="color:${d1L >= 0 ? '#3ddc84' : '#ff4d6d'}">${d1L >= 0 ? 'd1 > 0  â†’  IncV2 is INSIDE âœ“' : 'd1 < 0  â†’  IncV2 is OUTSIDE âœ—'}</b>`,
        dur: 1000,
        targets: { pI2: 1, d1: 1 }
      });

      // STEP 6
      addStep({
        title: 'Step 6 â€” Left Boundary: Pass or Fail?',
        phase: 'Left Clip',
        say: `The left boundary at Reference Vertex 1. ${iv1in ? 'IncV1 passes' : 'IncV1 fails'}, and ${iv2in ? 'IncV2 passes' : 'IncV2 fails'}. ${crossesL ? 'One is outside â€” we must clip.' : iv1in && iv2in ? 'Both pass â€” no clipping needed!' : 'Both fail â€” entire edge is discarded.'}`,
        desc: `Red zone = outside (behind RefV1).<br><b style="color:${iv1in ? '#3ddc84' : '#ff4d6d'}">IncV1: ${iv1in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b>   <b style="color:${iv2in ? '#3ddc84' : '#ff4d6d'}">IncV2: ${iv2in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b>`,
        dur: 1150,
        targets: { shL: 1, pf: 1 }
      });

      if (crossesL) {
        addStep({
          title: 'Step 7 â€” The Incident Edge as a Vector',
          phase: 'Left Clip',
          say: `We view the incident edge as a vector arrow from IncV1 to IncV2. A fraction t will walk along this arrow to find the boundary crossing.`,
          desc: `The full incident edge as vector: <b style="color:#ff4d6d">IncV1 â†’ IncV2</b>.<br>t=0 means start, t=1 means end. We will solve for the t where the edge crosses the boundary.`,
          dur: 1000,
          targets: { showFullVec: 1 }
        });
        addStep({
          title: 'Step 8 â€” Find the Crossing with t',
          phase: 'Left Clip',
          say: `t equals d0 divided by d0 minus d1. Because d0 and d1 have opposite signs, t lands between 0 and 1. Watch the arrow grow and stop at the crossing!`,
          desc: `<code>t = d0 / (d0 âˆ’ d1) = ${tL !== null ? tL.toFixed(4) : 'N/A'}</code><br>t is the <b>fraction along the edge</b> where it crosses the left boundary.`,
          dur: 2200,
          targets: { showFullVec: 1, tFrac: 1 }
        });
        addStep({
          title: 'Step 9 â€” Compute & Place the Clip Point',
          phase: 'Left Clip',
          say: `The clip point is IncV1 plus t times the vector from IncV1 to IncV2. This lands exactly on the boundary.`,
          desc: `<code>ClipPoint = IncV1 + t Ã— (IncV2 âˆ’ IncV1)</code><br>This new point lies exactly on the left boundary.`,
          dur: 850,
          targets: { cpL: 1 }
        });
      }

      addStep({
        title: `Step ${steps.length + 1} â€” Left Clip Result`,
        phase: 'Left Clip',
        say: `After the left clip: ${leftOut.length === 0 ? 'both were outside â€” nothing remains.' : crossesL ? 'we kept the surviving vertex plus the clip point.' : 'both pass â€” no clipping needed.'}`,
        desc: `Left clip complete. Keeping: <b style="color:#ff4d6d">${leftOut.length === 0 ? 'nothing (fully clipped)' : crossesL ? '[surviving vertex + Clip Point]' : '[both vertices â€” no clip]'}</b>${leftOut.length === 2 ? '<br>Dashed red = new incident edge.' : ''}`,
        dur: 950,
        targets: { lOut: 1 }
      });

      if (leftOut.length === 2) {
        // Transition â€” fade left phase, show new incident
        addStep({
          title: `Step ${steps.length + 1} â€” Start Right Clip`,
          phase: 'Right Clip',
          say: `The left clip output becomes our new incident edge. We now check: does any part of it extend past Reference Vertex 2 on the right?`,
          desc: `Left-clip output â†’ <b style="color:#ff8c42">new incident edge</b> for the right clip.`,
          dur: 1050,
          // Fade out left-phase state, fade in newInc
          targets: {
            inc: 0, lOut: 0, pf: 0, shL: 0,
            pI1: 0, d0: 0, pI2: 0, d1: 0,
            tI1: 0, tI2: 0, tang: 0,
            showFullVec: 0, tFrac: 0, cpL: 0,
            newInc: 1
          }
        });

        addStep({
          title: `Step ${steps.length + 1} â€” Flip the Tangent`,
          phase: 'Right Clip',
          say: `We reverse T-hat to get negative T-hat. Now it points right to left, and our anchor switches to Reference Vertex 2. Anything past it is outside.`,
          desc: `<code>âˆ’TÌ‚ = TÌ‚ Ã— âˆ’1</code> â€” now points right to left. Anchor = <b style="color:#3ddc84">RefV2</b>.<br>Right zone = outside.`,
          dur: 950,
          targets: { negT: 1, shR: 1 }
        });

        addStep({
          title: `Step ${steps.length + 1} â€” Vectors from RefV2`,
          phase: 'Right Clip',
          say: `Vectors from Reference Vertex 2 to each vertex of the new incident edge. We project these onto negative T-hat.`,
          desc: `Arrows from <b style="color:#3ddc84">RefV2</b> to each vertex.<br>Project onto âˆ’TÌ‚ to measure each vertex.`,
          dur: 950,
          targets: { tI1R: 1, tI2R: 1 }
        });

        addStep({
          title: `Step ${steps.length + 1} â€” Right Boundary: Pass or Fail?`,
          phase: 'Right Clip',
          say: `d0 is ${d0R !== null ? d0R.toFixed(1) : '?'}, ${lo0in ? 'positive â€” inside.' : 'negative â€” outside.'} d1 is ${d1R !== null ? d1R.toFixed(1) : '?'}, ${lo1in ? 'positive â€” inside.' : 'negative â€” outside.'} ${crossesR ? 'One is outside â€” we clip again.' : 'Both are inside â€” no right clipping needed!'}`,
          desc: `<code>d0 = ${d0R !== null ? d0R.toFixed(1) : '?'}</code> â†’ <b style="color:${lo0in ? '#3ddc84' : '#ff4d6d'}">${lo0in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b><br><code>d1 = ${d1R !== null ? d1R.toFixed(1) : '?'}</code> â†’ <b style="color:${lo1in ? '#3ddc84' : '#ff4d6d'}">${lo1in ? 'INSIDE âœ“' : 'OUTSIDE âœ—'}</b>`,
          dur: 1150,
          targets: { pI1R: 1, d0R: 1, pI2R: 1, d1R: 1, pfR: 1 }
        });

        if (crossesR) {
          addStep({
            title: `Step ${steps.length + 1} â€” Right Edge as a Vector`,
            phase: 'Right Clip',
            say: `The new incident edge as a vector arrow from NewV1 to NewV2. We compute t again to find where it crosses the right boundary.`,
            desc: `New incident edge as vector: <b style="color:#ff4d6d">NewV1 â†’ NewV2</b>.<br>Compute t to find the right boundary crossing.`,
            dur: 950,
            targets: { showFullVecR: 1 }
          });
          addStep({
            title: `Step ${steps.length + 1} â€” Find the Right Crossing`,
            phase: 'Right Clip',
            say: `t equals d0 divided by d0 minus d1 again. Watch the arrow grow and stop at Reference Vertex 2.`,
            desc: `<code>t = d0 / (d0 âˆ’ d1) = ${tR !== null ? tR.toFixed(4) : 'N/A'}</code><br>Watch the arrow grow and stop at the right boundary!`,
            dur: 2200,
            targets: { showFullVecR: 1, tFracR: 1 }
          });
          addStep({
            title: `Step ${steps.length + 1} â€” Place the Right Clip Point`,
            phase: 'Right Clip',
            say: `Using t, we place the right clip point exactly on the right boundary at Reference Vertex 2.`,
            desc: `<code>ClipPoint = NewV1 + t Ã— (NewV2 âˆ’ NewV1)</code><br>This point lies exactly on the right boundary.`,
            dur: 850,
            targets: { cpR: 1 }
          });
        }

        // Depth filter
        addStep({
          title: `Step ${steps.length + 1} â€” Candidate Points`,
          phase: 'Depth Filter',
          say: `After both clips, we have candidate contact points. But we need one final check â€” some might be above the reference edge and not actually touching it.`,
          desc: `Clipping done! Here are the <b style="color:#b48eff">candidate contact points</b>.<br>Final step: filter out any points <b>above</b> the reference edge.`,
          dur: 1000,
          targets: {
            showCandidates: 1,
            shR: 0, negT: 0, newInc: 0,
            tI1R: 0, tI2R: 0, pI1R: 0, d0R: 0, pI2R: 0, d1R: 0, pfR: 0,
            showFullVecR: 0, tFracR: 0, cpR: 0
          }
        });

        addStep({
          title: `Step ${steps.length + 1} â€” The Reference Normal`,
          phase: 'Depth Filter',
          say: `The Reference Normal is a vector perpendicular to the edge, pointing inward into the solid object. It defines the "inside" direction.`,
          desc: `<code>refNormal</code> = perpendicular to the reference edge, pointing inward.<br>Tells us which way is "inside" the reference face.`,
          dur: 1000,
          targets: { showRefNorm: 1 }
        });

        addStep({
          title: `Step ${steps.length + 1} â€” The Clipping Boundary`,
          phase: 'Depth Filter',
          say: `Anything below the reference edge â€” in the direction of the normal â€” is inside. Anything above is outside.`,
          desc: `The <b style="color:#ff4d6d">red zone</b> is "above" the reference edge.<br>Points there don't touch the face and must be discarded.`,
          dur: 1000,
          targets: { showDepthShade: 1 }
        });

        addStep({
          title: `Step ${steps.length + 1} â€” Depth Check`,
          phase: 'Depth Filter',
          say: `We measure each point's depth. Positive depth â€” inside, keep it. Negative depth â€” outside, discard it.`,
          desc: `<code>depth = dot(point, refNormal) âˆ’ refDist</code><br>depth â‰¥ 0 â†’ <b style="color:#3ddc84">KEEP</b> | depth < 0 â†’ <b style="color:#ff4d6d">DISCARD</b>`,
          dur: 1000,
          targets: { showDepth0: 1 }
        });

        if (candidatePoints.length >= 2) {
          addStep({
            title: `Step ${steps.length + 1} â€” Depth of Candidate 2`,
            phase: 'Depth Filter',
            say: `Measuring the second candidate. depth equals ${depthValues[1] !== undefined ? depthValues[1].toFixed(2) : '?'}. ${depthValues[1] !== undefined ? depthValues[1] >= 0 ? 'Positive â€” keep it!' : 'Negative â€” discard it.' : ''}`,
            desc: `Candidate 2: <code>depth = ${depthValues[1] !== undefined ? depthValues[1].toFixed(2) : '?'}</code><br><b style="color:${depthValues[1] !== undefined && depthValues[1] >= 0 ? '#3ddc84' : '#ff4d6d'}">${depthValues[1] !== undefined ? depthValues[1] >= 0 ? 'depth â‰¥ 0  â†’  KEEP âœ“' : 'depth < 0  â†’  DISCARD âœ—' : ''}</b>`,
            dur: 1050,
            targets: { showDepth1: 1 }
          });
        }

        addStep({
          title: `Step ${steps.length + 1} â€” Keep Valid Contact Points`,
          phase: 'Depth Filter',
          say: `Keeping only depth â‰¥ 0 points. ${contactPoints.length === 0 ? 'None survived.' : contactPoints.length === 1 ? 'One point survived â€” single contact.' : 'Two points survived â€” final contact edge.'}`,
          desc: `<code>if (depth â‰¥ 0) keep</code><br><b style="color:#ffd166">${contactPoints.length} valid contact point${contactPoints.length !== 1 ? 's' : ''} survived.</b>`,
          dur: 1000,
          targets: { showKept: 1 }
        });
      }

      // FINAL
      addStep({
        title: `ğŸ‰ Step ${steps.length + 1} â€” Final Result!`,
        phase: 'Done',
        say: `And there it is â€” shown in yellow. ${contactPoints.length === 2 ? 'Two contact points forming the final contact edge.' : contactPoints.length === 1 ? 'One contact point â€” the edges touch at a single location.' : 'No contact â€” the edges do not intersect.'}`,
        desc: `<b style="color:#ffd166">Yellow = final clipped edge</b> â€” the true intersection region!`,
        dur: 1100,
        targets: { final: 1 }
      });

      addStep({
        title: `ğŸ‰ Done! â€” Sutherland-Hodgman Complete`,
        phase: 'Done',
        say: `Left clip, right clip, depth filter â€” all done! These contact points drive the physics impulse calculations.`,
        desc: `Left clip â†’ Right clip â†’ Depth filter â†’ <b style="color:#ffd166">Result!</b>`,
        dur: 1100,
        targets: { final: 1 }
      });

      return steps;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP PLAYBACK ENGINE â€” FIX
    //
    // Core idea:
    //  - `stateSnapshots[i]` = the full S after step i completes (all keys at final value).
    //  - When we go to step i, we tween from stateSnapshots[i-1] (or all-zero for step 0)
    //    to stateSnapshots[i].
    //  - For steps with special animated keys (tFrac, tFracR) we still run a special
    //    in-between animation.
    //  - Prev simply goes to i-1, which is already correct because the snapshot is pre-built.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let steps = [], curStep = -1;
    let stateSnapshots = []; // stateSnapshots[i] = final S after step i

    // These keys animate specially (grow 0â†’1 during the step, but their SNAPSHOT value is 1)
    const ANIM_KEYS_TWEEN = ['tFrac', 'tFracR'];

    // Build snapshots from steps
    function buildSnapshots(stps) {
      const snaps = [];
      let cur = {};
      for (const k of STATE_KEYS) cur[k] = 0;
      for (const step of stps) {
        // apply targets
        if (step.targets) {
          for (const [k, v] of Object.entries(step.targets)) {
            cur[k] = v;
          }
        }
        snaps.push({ ...cur });
      }
      return snaps;
    }

    function applySnapshot(snap) {
      for (const k of STATE_KEYS) S[k] = snap[k] ?? 0;
    }

    // RAF state
    let rafID = null, animT = null, animFrom = null, animTo = null, animDur = 0;
    let isAnimating = false;

    function cancelAnim() {
      if (rafID) { cancelAnimationFrame(rafID); rafID = null; }
      isAnimating = false; animT = null;
    }

    function lerpState(from, to, t) {
      for (const k of STATE_KEYS) {
        const fv = from[k] ?? 0, tv = to[k] ?? 0;
        S[k] = fv + (tv - fv) * t;
      }
    }

    // Special case: tFrac and tFracR need to animate 0â†’their-target, not just lerp
    // The targets for those in the snapshot will be the final value (1 if the step sets them)
    // During animation we want them to sweep from 0 to 1 (eased), which equals their target anyway.
    // So regular lerp is actually correct! The arrow grows from 0â†’target value.
    // No special case needed.

    function runAnimFrame(ts) {
      if (!animT) animT = ts;
      const el = ts - animT;
      const raw = Math.min(1, el / animDur);
      const t = eIO(raw);
      lerpState(animFrom, animTo, t);
      drawScene();
      if (raw < 1) {
        rafID = requestAnimationFrame(runAnimFrame);
      } else {
        applySnapshot(animTo); // ensure exact final state
        drawScene();
        isAnimating = false;
        rafID = null;
        updateButtons();
        // auto-advance if in auto mode
        if (autoOn) scheduleAutoNext();
      }
    }

    function goToStep(i) {
      cancelAnim();
      if (window.speechSynthesis) speechSynthesis.cancel();

      curStep = i;
      const step = steps[i];
      const from = i === 0 ? Object.fromEntries(STATE_KEYS.map(k => [k, 0])) : stateSnapshots[i - 1];
      const to = stateSnapshots[i];

      document.getElementById('step-title').textContent = step.title;
      document.getElementById('step-desc').innerHTML = step.desc;
      document.getElementById('prog').textContent = `Step ${i + 1} / ${steps.length}`;
      document.getElementById('phase-badge').textContent = step.phase || '';
      updateDots();
      updateProgressBar();
      updateButtons();
      speak(step.say);

      animFrom = { ...from };
      animTo = { ...to };
      animDur = step.dur;
      animT = null;
      isAnimating = true;
      rafID = requestAnimationFrame(runAnimFrame);
    }

    function updateButtons() {
      document.getElementById('btnPrev').disabled = curStep <= 0;
      document.getElementById('btnNext').disabled = curStep >= steps.length - 1 || isAnimating;
    }

    function updateProgressBar() {
      const pct = steps.length > 1 ? (curStep / (steps.length - 1)) * 100 : 0;
      document.getElementById('progress-bar').style.width = pct + '%';
    }

    function updateDots() {
      const container = document.getElementById('step-dots');
      // rebuild dots if count changed
      if (container.children.length !== steps.length) {
        container.innerHTML = '';
        for (let i = 0; i < steps.length; i++) {
          const d = document.createElement('div');
          d.className = 'sdot';
          d.title = `Step ${i + 1}`;
          d.addEventListener('click', () => {
            if (isAnimating) return;
            if (i === curStep) return;
            if (i < curStep) { goPrev(curStep - i); }
            else { goNext(i - curStep); }
          });
          container.appendChild(d);
        }
      }
      const dots = container.querySelectorAll('.sdot');
      dots.forEach((d, i) => {
        d.classList.toggle('active', i === curStep);
        d.classList.toggle('done', i < curStep);
      });
    }

    // Sequential jump helpers
    function goNext(n = 1) {
      if (isAnimating) return;
      const target = Math.min(curStep + n, steps.length - 1);
      if (target <= curStep) return;
      goToStep(target);
    }
    function goPrev(n = 1) {
      if (isAnimating) return;
      const target = Math.max(curStep - n, 0);
      if (target === curStep) return;
      // Instantly apply snapshot for target, then animate one step back to that snapshot
      // Actually since snapshots are pre-built, just go directly
      goToStep(target);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUTO PLAY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let autoOn = false, autoTimer = null;

    function scheduleAutoNext() {
      if (!autoOn) return;
      if (curStep >= steps.length - 1) { stopAuto(); return; }
      // Wait a bit after animation finishes, then go next
      autoTimer = setTimeout(() => {
        if (!autoOn) return;
        goNext();
      }, 1800);
    }

    function stopAuto() {
      autoOn = false;
      clearTimeout(autoTimer); autoTimer = null;
      const btn = document.getElementById('btnAuto');
      btn.textContent = 'â–¶ Auto';
      btn.classList.remove('active-auto');
    }

    function startAuto() {
      autoOn = true;
      const btn = document.getElementById('btnAuto');
      btn.textContent = 'â–  Stop';
      btn.classList.add('active-auto');
      if (!isAnimating) {
        if (curStep >= steps.length - 1) { stopAuto(); return; }
        goNext();
      }
      // if animating, scheduleAutoNext will be called at animation end
    }

    document.getElementById('btnNext').onclick = () => {
      if (window.startBgMusic) window.startBgMusic();
      if (!isAnimating) goNext();
    };
    document.getElementById('btnPrev').onclick = () => { if (!isAnimating) goPrev(); };
    document.getElementById('btnAuto').onclick = () => {
      if (window.startBgMusic) window.startBgMusic();
      autoOn ? stopAuto() : startAuto();
    };

    document.getElementById('btnReset').onclick = () => {
      stopAuto();
      cancelAnim();
      if (window.speechSynthesis) speechSynthesis.cancel();
      resetS();
      curStep = -1;
      computeGeo();
      steps = buildSteps();
      stateSnapshots = buildSnapshots(steps);
      document.getElementById('step-title').textContent = 'Ready to Start';
      document.getElementById('step-desc').innerHTML = 'Drag the <b style="color:#3ddc84">green</b> or <b style="color:#ff8c42">orange</b> vertices on the canvas, then press <b>Next â†’</b> to begin.';
      document.getElementById('prog').textContent = `Step 0 / ${steps.length}`;
      document.getElementById('phase-badge').textContent = 'Ready';
      document.getElementById('progress-bar').style.width = '0%';
      updateDots();
      document.getElementById('btnPrev').disabled = true;
      document.getElementById('btnNext').disabled = false;
      drawScene();
    };

    document.getElementById('btnMute').onclick = () => {
      ttsOn = !ttsOn;
      document.getElementById('btnMute').textContent = ttsOn ? 'ğŸ”Š' : 'ğŸ”‡';
      if (!ttsOn && window.speechSynthesis) speechSynthesis.cancel();
    };

    const btnMuteMusic = document.getElementById('btnMuteMusic');
    if (btnMuteMusic) {
      btnMuteMusic.onclick = () => {
        if (window.toggleBgMusicMute) {
          const isMuted = window.toggleBgMusicMute();
          btnMuteMusic.style.opacity = isMuted ? '0.5' : '1';
        }
      };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    computeGeo();
    steps = buildSteps();
    stateSnapshots = buildSnapshots(steps);
    document.getElementById('prog').textContent = `Step 0 / ${steps.length}`;
    document.getElementById('btnPrev').disabled = true;
    updateDots();
    drawScene();
  </script>
  <script src="bg-music.js"></script>
</body>

</html>
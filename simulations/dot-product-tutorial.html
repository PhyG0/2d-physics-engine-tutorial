<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dot Product Interactive Tutorial ‚Äî Visual Vector Math Simulation | Phygo</title>
    <meta name="description"
        content="Learn the dot product through 26 interactive steps. Visualize vector projection, angle calculation, perpendicularity, lighting, field of view, and AI steering ‚Äî with narration and canvas animations.">
    <meta name="keywords"
        content="dot product tutorial, vector math visual, dot product applications, projection, perpendicular check, game physics math, vector angle, lighting normal, field of view, interactive math">
    <meta name="robots" content="index, follow">
    <link rel="canonical"
        href="https://phyg0.github.io/2d-physics-engine-tutorial/simulations/dot-product-tutorial.html">
    <meta property="og:type" content="article">
    <meta property="og:url"
        content="https://phyg0.github.io/2d-physics-engine-tutorial/simulations/dot-product-tutorial.html">
    <meta property="og:title" content="Dot Product Interactive Tutorial ‚Äî Visual Vector Math Simulation">
    <meta property="og:description"
        content="26-step interactive dot product tutorial: projection, angles, perpendicularity, lighting, FOV, and more.">
    <meta property="og:image" content="https://phyg0.github.io/2d-physics-engine-tutorial/phygo-logo.png">
    <meta property="og:site_name" content="Phygo">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap"
        rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            background: #07080f;
            color: #c9d1d9;
            font-family: 'Space Mono', monospace;
            font-size: 13px;
            overflow: hidden;
        }

        header {
            display: flex;
            align-items: baseline;
            gap: 12px;
            padding: 9px 18px 6px;
            border-bottom: 1px solid #1a1a2e;
        }

        header h1 {
            font-size: 1rem;
            color: #64ffda;
            letter-spacing: .06em;
        }

        header span {
            font-size: .6rem;
            color: #3a3a5c;
        }

        .main {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 38px);
            max-width: 850px;
            margin: 0 auto;
        }

        .toolbar {
            padding: 5px 14px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            border-bottom: 1px solid #111124;
            align-items: center;
        }

        button {
            background: #111124;
            border: 1px solid #1e1e40;
            color: #a0aec0;
            border-radius: 5px;
            padding: 4px 11px;
            font-family: 'Space Mono', monospace;
            font-size: .62rem;
            cursor: pointer;
            transition: all .15s;
        }

        button:hover:not(:disabled) {
            background: #1a1a40;
            border-color: #3a3a6a;
            color: #e2e8f0;
        }

        button.primary {
            background: #0d3d2e;
            border-color: #1a6a50;
            color: #64ffda;
        }

        button.primary:hover:not(:disabled) {
            background: #144d3a;
        }

        button:disabled {
            opacity: .3;
            cursor: not-allowed;
        }

        .sep {
            width: 1px;
            height: 22px;
            background: #1e1e40;
            margin: 0 2px;
        }

        .canvas-wrap {
            flex: 1;
            position: relative;
            min-height: 0;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 3fr 1fr 1fr 1.4fr;
            gap: 7px;
            padding: 7px 14px;
            background: #050509;
            border-top: 1px solid #111124;
        }

        .card {
            background: #0a0b17;
            border: 1px solid #141428;
            border-radius: 6px;
            padding: 7px 12px;
        }

        .step-card {
            padding: 7px 13px;
        }

        .snum {
            font-size: .55rem;
            color: #3a3a6a;
            margin-bottom: 2px;
        }

        .stitle {
            font-size: .82rem;
            font-weight: 700;
            color: #64ffda;
            margin-bottom: 3px;
        }

        .sdesc {
            font-size: .62rem;
            color: #8892a4;
            line-height: 1.6;
        }

        .sdesc em {
            color: #ffd166;
            font-style: normal;
        }

        .sdesc strong {
            color: #c9d1d9;
        }

        .sdesc code {
            background: #0f0f25;
            color: #a8ff78;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: .58rem;
        }

        .mbox {
            font-size: .62rem;
            color: #c77dff;
            font-style: italic;
            margin-top: 3px;
        }

        .sec {
            font-size: .52rem;
            color: #3a3a6a;
            letter-spacing: .1em;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .leg-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: .58rem;
            color: #8892a4;
            margin-bottom: 3px;
        }

        .dot-lg {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .lsw {
            width: 18px;
            height: 3px;
            flex-shrink: 0;
        }

        .prog-bar-bg {
            background: #111124;
            border-radius: 10px;
            height: 5px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .prog-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ffda, #00b4d8);
            border-radius: 10px;
            transition: width .4s ease;
        }

        .prog-lbl {
            display: flex;
            justify-content: space-between;
            font-size: .52rem;
            color: #3a3a6a;
        }

        .chapter-lbl {
            font-size: .52rem;
            color: #c77dff;
            margin-top: 5px;
        }

        select {
            width: 100%;
            background: #080810;
            color: #c9d1d9;
            border: 1px solid #1e1e2e;
            border-radius: 4px;
            padding: .28rem .45rem;
            font-family: 'Space Mono', monospace;
            font-size: .58rem;
            margin-bottom: 4px;
        }
    </style>
</head>

<body>
    <header>
        <h1>Dot Product</h1>
        <span>Interactive Tutorial ‚Äî 26 Steps</span>
    </header>
    <div class="main">
        <div class="toolbar">
            <button id="btnPrev" disabled>‚Üê Prev</button>
            <button id="btnNext" class="primary">Next ‚Üí</button>
            <button id="btnAuto">‚ñ∂ Auto</button>
            <button id="btnReset">‚Ü∫ Reset</button>
            <div class="sep"></div>
            <button id="btnMute" title="Toggle narration">üîä</button>
            <button id="btnMuteMusic" title="Toggle music">üéµ</button>
        </div>
        <div class="canvas-wrap"><canvas id="c"></canvas></div>
        <div class="info-grid">
            <div class="card step-card">
                <div class="snum" id="sNum">‚Äì</div>
                <div class="stitle" id="sTitle">Welcome</div>
                <div class="sdesc" id="sDesc">Press Next to begin.</div>
                <div class="mbox" id="mBox"></div>
            </div>
            <div class="card">
                <div class="sec">Legend</div>
                <div class="leg-item">
                    <div class="dot-lg" style="background:#64ffda"></div>Vector A
                </div>
                <div class="leg-item">
                    <div class="dot-lg" style="background:#ff6b9d"></div>Vector B
                </div>
                <div class="leg-item">
                    <div class="lsw" style="background:#ffd166"></div>Angle arc Œ∏
                </div>
                <div class="leg-item">
                    <div class="lsw" style="background:#c77dff;border-top:1px dashed #c77dff;height:0"></div>Projection
                </div>
            </div>
            <div class="card">
                <div class="sec">Progress</div>
                <div class="prog-bar-bg">
                    <div class="prog-bar-fill" id="pFill" style="width:0%"></div>
                </div>
                <div class="prog-lbl"><span id="pL">Step 1</span><span id="pR">of ‚Äì</span></div>
                <div class="chapter-lbl" id="chapterLbl"></div>
            </div>
            <div class="card">
                <div class="sec">Narration</div>
                <select id="ttsVoice">
                    <option value="">Default voice</option>
                </select>
            </div>
        </div>
    </div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  CANVAS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const C = document.getElementById('c'), X = C.getContext('2d'), WR = C.parentElement;
        function resize() { C.width = WR.clientWidth; C.height = WR.clientHeight; }
        resize(); window.addEventListener('resize', resize);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  MATH
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const V = (x, y) => ({ x, y });
        const add = (a, b) => V(a.x + b.x, a.y + b.y);
        const sub = (a, b) => V(a.x - b.x, a.y - b.y);
        const mul = (a, s) => V(a.x * s, a.y * s);
        const dot = (a, b) => a.x * b.x + a.y * b.y;
        const mg = a => Math.sqrt(a.x * a.x + a.y * a.y);
        const hat = a => { const m = mg(a) || 1; return V(a.x / m, a.y / m); };
        const lerp = (a, b, t) => a + (b - a) * t;
        const lerpV = (a, b, t) => V(lerp(a.x, b.x, t), lerp(a.y, b.y, t));
        const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
        const d2r = d => d * Math.PI / 180;
        const r2d = r => r * 180 / Math.PI;

        function getOrigin() { return V(C.width * .5, C.height * .46); }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  SCENE STATE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const scene = { a: V(110, -70), b: V(100, 80), light: V(80, -120), look: V(100, 0), enemy: V(100, 50), pt: V(80, -80), vel: V(80, 80), camTarget: V(100, -60) };
        const tgt = { a: V(110, -70), b: V(100, 80), light: V(80, -120), look: V(100, 0), enemy: V(100, 50), pt: V(80, -80), vel: V(80, 80), camTarget: V(100, -60) };
        const ST = 0.13;
        function setTgt(k, v) { tgt[k] = v; }
        function updateScene() { for (const k of Object.keys(scene)) scene[k] = lerpV(scene[k], tgt[k], ST); }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DRAW PRIMITIVES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function bg() {
            const o = getOrigin();
            X.fillStyle = '#07080f'; X.fillRect(0, 0, C.width, C.height);
            X.strokeStyle = 'rgba(255,255,255,.016)'; X.lineWidth = 1;
            const g = 44;
            for (let x = 0; x < C.width; x += g) { X.beginPath(); X.moveTo(x, 0); X.lineTo(x, C.height); X.stroke(); }
            for (let y = 0; y < C.height; y += g) { X.beginPath(); X.moveTo(0, y); X.lineTo(C.width, y); X.stroke(); }
            X.strokeStyle = 'rgba(255,255,255,.08)'; X.lineWidth = 1;
            X.beginPath(); X.moveTo(0, o.y); X.lineTo(C.width, o.y); X.stroke();
            X.beginPath(); X.moveTo(o.x, 0); X.lineTo(o.x, C.height); X.stroke();
        }

        function arrow(x1, y1, x2, y2, col, lw = 3, hs = 17, alpha = 1) {
            X.save(); X.globalAlpha = alpha; X.strokeStyle = col; X.fillStyle = col; X.lineWidth = lw; X.lineCap = 'round';
            const dx = x2 - x1, dy = y2 - y1, d = Math.sqrt(dx * dx + dy * dy);
            if (d < 1) { X.restore(); return; }
            X.beginPath(); X.moveTo(x1, y1); X.lineTo(x2, y2); X.stroke();
            const ux = dx / d, uy = dy / d;
            X.beginPath(); X.moveTo(x2, y2);
            X.lineTo(x2 - hs * ux + hs * .4 * (-uy), y2 - hs * uy + hs * .4 * ux);
            X.lineTo(x2 - hs * ux - hs * .4 * (-uy), y2 - hs * uy - hs * .4 * ux);
            X.closePath(); X.fill(); X.restore();
        }

        function circ(x, y, r, col, alpha = 1) {
            X.save(); X.globalAlpha = alpha; X.beginPath(); X.arc(x, y, r, 0, Math.PI * 2); X.fillStyle = col; X.fill(); X.restore();
        }

        function pill(text, x, y, col, bg = 'rgba(10,11,23,0.92)', alpha = 1) {
            X.save(); X.globalAlpha = alpha;
            X.font = "bold 11px 'Space Mono',monospace"; X.textBaseline = 'middle'; X.textAlign = 'center';
            const m = X.measureText(text), w = m.width + 13, h = 20, r = 5;
            X.shadowColor = 'rgba(0,0,0,.7)'; X.shadowBlur = 6;
            X.fillStyle = bg; X.beginPath(); X.roundRect(x - w / 2, y - h / 2, w, h, r); X.fill();
            X.shadowColor = 'transparent'; X.fillStyle = col; X.fillText(text, x, y + 1);
            X.restore();
        }

        function drawAngleArc(o, a, b, radius, lbl) {
            const angA = Math.atan2(a.y, a.x), angB = Math.atan2(b.y, b.x);
            let s = angA, e = angB, diff = e - s;
            if (diff > Math.PI) s += 2 * Math.PI;
            if (diff < -Math.PI) e += 2 * Math.PI;
            X.save(); X.strokeStyle = 'rgba(255,209,102,.65)'; X.lineWidth = 2; X.setLineDash([4, 3]);
            X.beginPath(); X.arc(o.x, o.y, radius, Math.min(s, e), Math.max(s, e)); X.stroke();
            X.setLineDash([]);
            const mid = (s + e) / 2;
            pill(lbl || 'Œ∏', o.x + Math.cos(mid) * (radius + 18), o.y + Math.sin(mid) * (radius + 18), '#ffd166');
            X.restore();
        }

        function drawProjection(o, a, b) {
            const bh = hat(b), plen = dot(a, bh), pp = add(o, mul(bh, plen)), tipA = add(o, a);
            X.save(); X.strokeStyle = 'rgba(199,125,255,.45)'; X.lineWidth = 1.5; X.setLineDash([5, 5]);
            X.beginPath(); X.moveTo(tipA.x, tipA.y); X.lineTo(pp.x, pp.y); X.stroke();
            X.setLineDash([]); X.restore();
            X.save(); X.strokeStyle = '#c77dff'; X.lineWidth = 3; X.lineCap = 'round';
            X.beginPath(); X.moveTo(o.x, o.y); X.lineTo(pp.x, pp.y); X.stroke(); X.restore();
            circ(pp.x, pp.y, 4, '#c77dff');
            pill('proj', pp.x, pp.y - 15, '#c77dff');
        }

        function drawVector(o, v, col, lbl, showComp, prefix) {
            const tip = add(o, v);
            arrow(o.x, o.y, tip.x, tip.y, col, 3.2, 20);
            circ(tip.x, tip.y, 6, col);
            if (lbl) pill(lbl, tip.x + (v.x >= 0 ? 20 : -20), tip.y - 15, col);
            if (showComp) {
                X.save(); X.strokeStyle = col; X.globalAlpha = .28; X.lineWidth = 1.5; X.setLineDash([4, 4]);
                X.beginPath(); X.moveTo(o.x, o.y); X.lineTo(o.x + v.x, o.y); X.stroke();
                X.beginPath(); X.moveTo(o.x + v.x, o.y); X.lineTo(tip.x, tip.y); X.stroke();
                X.setLineDash([]); X.restore();
                pill(`${prefix || ''}x=${v.x.toFixed(0)}`, o.x + v.x / 2, o.y + (v.y > 0 ? -14 : 14), col, null, .85);
                pill(`${prefix || ''}y=${(-v.y).toFixed(0)}`, o.x + v.x + (v.x > 0 ? 20 : -20), o.y + v.y / 2, col, null, .85);
            }
        }

        function drawRightAngle(o, a, b, sz = 13) {
            const ua = hat(a), ub = hat(b);
            const p1 = add(o, mul(ua, sz)), p2 = add(add(o, mul(ua, sz)), mul(ub, sz)), p3 = add(o, mul(ub, sz));
            X.save(); X.strokeStyle = 'rgba(255,255,255,.32)'; X.lineWidth = 1.5;
            X.beginPath(); X.moveTo(p1.x, p1.y); X.lineTo(p2.x, p2.y); X.lineTo(p3.x, p3.y); X.stroke(); X.restore();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  TUTORIAL STEPS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let tutCur = 0, tutSteps = [];

        const CHAPTERS = { 0: 'Foundations', 5: 'The Dot Product', 10: 'Geometric Interpretation', 15: 'Applications', 21: 'Advanced Topics' };

        function buildTutorial() {
            tutSteps = [

                // 0
                {
                    title: 'Welcome', chapter: 'Foundations',
                    narrate: '',
                    desc: 'This tutorial teaches you <em>vectors</em> and the <em>dot product</em> ‚Äî from first principles to real-world game engine applications. Use Next to advance, or hit Auto for a fully narrated tour.',
                    enter() { setTgt('a', V(110, -70)); setTgt('b', V(100, 80)); },
                    draw(o) {
                        pill('Vectors & the Dot Product', o.x, o.y - 55, '#fff', null, 1);
                        pill('A visual, narrated guide  ¬∑  26 steps', o.x, o.y - 26, '#5a6070', null, .85);
                        drawVector(o, scene.a, '#64ffda', 'A');
                        drawVector(o, scene.b, '#ff6b9d', 'B');
                        circ(o.x, o.y, 5, '#fff');
                    }
                },

                // 1
                {
                    title: 'What is a Vector?', chapter: 'Foundations',
                    narrate: 'A vector is simply an arrow. It carries exactly two pieces of information: a direction ‚Äî which way the arrow points ‚Äî and a magnitude, or length. Unlike a plain number, a vector lives in space. In two dimensions we write it as two numbers in parentheses: the horizontal part called X, and the vertical part called Y.',
                    desc: 'A <em>vector</em> = direction + magnitude.<br>Written as <em>(x, y)</em> ‚Äî two components.',
                    enter() { setTgt('a', V(160, -100)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', '', false);
                        const tip = add(o, scene.a), mid = lerpV(o, tip, .5);
                        pill('direction ‚Üí', mid.x - 44, mid.y - 18, '#ffd166');
                        pill('magnitude = ' + mg(scene.a).toFixed(0) + ' units', mid.x + 42, mid.y + 16, '#a8ff78');
                        circ(o.x, o.y, 5, '#fff');
                        pill('tail', o.x - 26, o.y + 16, '#5a6070');
                        pill('head / tip', tip.x + 42, tip.y, '#64ffda');
                    }
                },

                // 2
                {
                    title: 'X and Y Components', chapter: 'Foundations',
                    narrate: 'Every vector breaks into a horizontal run and a vertical rise. We call these the X component and the Y component. On screen Y increases downward, so an arrow pointing upward has a negative Y. This vector has X equal to 160 and Y equal to negative 100.',
                    desc: 'Horizontal = <em>x-component</em>, vertical = <em>y-component</em>.<br>Screen: up = negative Y.',
                    enter() { setTgt('a', V(160, -100)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', '', true);
                        const tip = add(o, scene.a);
                        pill('(160, ‚àí100)', tip.x + 14, tip.y - 16, '#64ffda');
                        circ(o.x, o.y, 5, '#fff');
                    }
                },

                // 3
                {
                    title: 'Vector Notation', chapter: 'Foundations',
                    narrate: 'Mathematicians write vectors in several equivalent ways. Bold letter v, a letter with an arrow on top, a column matrix, or in code a struct with x and y fields. They all describe the same thing: a direction and a length packed into components.',
                    desc: 'All equivalent: <em>v</em> (bold), <em>v‚Éó</em> (arrow), column matrix, or <code>{x,y}</code> in code.',
                    enter() { setTgt('a', V(130, -90)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', '', false);
                        const cx = o.x - 155, cy = o.y - 50;
                        pill('v  (bold letter)', cx, cy, '#64ffda');
                        pill('v‚Éó  (arrow over letter)', cx, cy + 26, '#64ffda');
                        pill('column: [ x, y ]·µÄ', cx, cy + 52, '#ffd166');
                        pill('code: { x: 130, y: -90 }', o.x + 80, o.y + 80, '#a8ff78');
                        circ(o.x, o.y, 5, '#fff');
                    }
                },

                // 4
                {
                    title: 'Scaling a Vector', chapter: 'Foundations',
                    narrate: 'Multiplying a vector by a scalar ‚Äî a plain number ‚Äî stretches or shrinks it without changing its direction. Multiply by 2 and the vector doubles. Multiply by 0.5 and it halves. Multiply by negative 1 and the vector flips to point the opposite way.',
                    desc: 'Scalar multiply: scale length, keep direction. Negative scalar <em>flips</em> direction.',
                    enter() { setTgt('a', V(100, -60)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        const v = scene.a;
                        const o1 = V(o.x - 170, o.y + 10), o2 = V(o.x, o.y + 10), o3 = V(o.x + 170, o.y + 10);
                        drawVector(o1, mul(v, .5), '#64ffda', ''); pill('0.5 √ó v', o1.x, o1.y + 54, '#64ffda');
                        drawVector(o2, v, '#a8ff78', ''); pill('1.0 √ó v  (original)', o2.x, o2.y + 54, '#a8ff78');
                        drawVector(o3, mul(v, -1), '#ff6b9d', ''); pill('‚àí1 √ó v  (flipped)', o3.x, o3.y + 54, '#ff6b9d');
                    }
                },

                // 5
                {
                    title: 'Adding Two Vectors', chapter: 'The Dot Product',
                    narrate: 'To add two vectors, place the tail of the second at the tip of the first. The result goes from the original tail all the way to the final tip. Component-wise: add Xs together and Ys together. This is the standard tip-to-tail, or parallelogram, method.',
                    desc: 'Tip-to-tail: <em>(Ax+Bx, Ay+By)</em>.',
                    enter() { setTgt('a', V(120, -40)); setTgt('b', V(60, -90)); },
                    draw(o) {
                        const tipA = add(o, scene.a), tipAB = add(tipA, scene.b);
                        arrow(o.x, o.y, tipA.x, tipA.y, '#64ffda', 3, 20);
                        pill('A', lerpV(o, tipA, .5).x - 14, lerpV(o, tipA, .5).y - 14, '#64ffda');
                        arrow(tipA.x, tipA.y, tipAB.x, tipAB.y, '#ff6b9d', 3, 20);
                        pill('B', lerpV(tipA, tipAB, .5).x + 14, lerpV(tipA, tipAB, .5).y, '#ff6b9d');
                        arrow(o.x, o.y, tipAB.x, tipAB.y, '#a8ff78', 2.5, 18, .8);
                        pill('A + B', lerpV(o, tipAB, .5).x - 34, lerpV(o, tipAB, .5).y - 14, '#a8ff78');
                        const fy = o.y + 80, sum = add(scene.a, scene.b);
                        pill(`A   = (${scene.a.x.toFixed(0)}, ${(-scene.a.y).toFixed(0)})`, o.x, fy, '#64ffda');
                        pill(`B   = (${scene.b.x.toFixed(0)}, ${(-scene.b.y).toFixed(0)})`, o.x, fy + 24, '#ff6b9d');
                        pill(`A+B = (${sum.x.toFixed(0)}, ${(-sum.y).toFixed(0)})`, o.x, fy + 48, '#a8ff78');
                        circ(o.x, o.y, 5, '#fff');
                    }
                },

                // 6
                {
                    title: 'Subtracting Vectors', chapter: 'The Dot Product',
                    narrate: 'B minus A gives the vector that starts at point A and points toward point B. Think of it as the journey from A to B. This is extremely common in games ‚Äî compute the direction from a player to an enemy, or from a camera to its target.',
                    desc: '<em>B ‚àí A</em> = vector pointing from A toward B.',
                    enter() { setTgt('a', V(-110, 30)); setTgt('b', V(90, -50)); },
                    draw(o) {
                        const pA = add(o, scene.a), pB = add(o, scene.b);
                        circ(pA.x, pA.y, 8, '#64ffda'); pill('A', pA.x - 22, pA.y + 18, '#64ffda');
                        circ(pB.x, pB.y, 8, '#ff6b9d'); pill('B', pB.x + 16, pB.y - 15, '#ff6b9d');
                        arrow(pA.x, pA.y, pB.x, pB.y, '#ffd166', 3, 20);
                        pill('B ‚àí A', lerpV(pA, pB, .5).x, lerpV(pA, pB, .5).y - 18, '#ffd166');
                        const diff = sub(scene.b, scene.a);
                        pill(`B‚àíA = (${diff.x.toFixed(0)}, ${(-diff.y).toFixed(0)})   length = ${mg(diff).toFixed(0)}`, o.x, o.y + 100, '#ffd166');
                    }
                },

                // 7
                {
                    title: 'Magnitude (Length)', chapter: 'The Dot Product',
                    narrate: 'The magnitude of a vector is its length. We compute it using the Pythagorean theorem: square root of X squared plus Y squared. Two vertical bars around the vector name denote magnitude. This gives the straight-line distance from tail to tip.',
                    desc: '‚Äñv‚Äñ = <em>‚àö(x¬≤ + y¬≤)</em> ‚Äî Pythagorean theorem applied to components.',
                    enter() { setTgt('a', V(120, -90)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', '', true);
                        circ(o.x, o.y, 5, '#fff');
                        const fy = o.y + 75;
                        pill('Step 1:  x¬≤ = 120¬≤ = 14 400', o.x, fy, '#ffd166');
                        pill('Step 2:  y¬≤ =  90¬≤ =  8 100', o.x, fy + 26, '#c77dff');
                        pill('Step 3:  ‚àö(22 500) = 150', o.x, fy + 52, '#a8ff78');
                        pill('‚Äñv‚Äñ = 150', o.x + scene.a.x * .55, o.y + scene.a.y * .55 - 14, '#a8ff78');
                    }
                },

                // 8
                {
                    title: 'Unit Vectors (Normalizing)', chapter: 'The Dot Product',
                    narrate: 'A unit vector has a magnitude of exactly 1. You get it by dividing every component by the original length. This is called normalizing. Unit vectors represent pure direction with no length baggage, which makes calculations cleaner and faster.',
                    desc: '<em>√ª = v / ‚Äñv‚Äñ</em> ‚Äî divide by length. Pure direction, magnitude = 1.',
                    enter() { setTgt('a', V(120, -90)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', '', false);
                        pill('original  ‚Äñv‚Äñ = 150', o.x + scene.a.x + 10, o.y + scene.a.y - 12, '#64ffda');
                        const uv = hat(scene.a), uvO = V(o.x, o.y + 100);
                        arrow(uvO.x, uvO.y, uvO.x + uv.x * 80, uvO.y + uv.y * 80, '#a8ff78', 3.5, 18);
                        pill('unit vector  ‚Äñ√ª‚Äñ = 1', uvO.x + uv.x * 80 + 10, uvO.y + uv.y * 80 - 12, '#a8ff78');
                        circ(o.x, o.y, 5, '#fff'); circ(uvO.x, uvO.y, 5, '#fff');
                        pill('√ª = (120√∑150, ‚àí90√∑150) = (0.8, ‚àí0.6)', o.x, o.y + 165, '#ffd166');
                    }
                },

                // 9
                {
                    title: 'The Dot Product Formula', chapter: 'The Dot Product',
                    narrate: 'The dot product of two vectors gives a single number. Multiply the X components together, multiply the Y components together, then add both results. The dot symbol sits between the two vector names. The result is a scalar ‚Äî just a number, no direction.',
                    desc: '<code>A ¬∑ B = (Ax √ó Bx) + (Ay √ó By)</code><br>Result is a <em>scalar</em> ‚Äî a single number.',
                    enter() { setTgt('a', V(140, -60)); setTgt('b', V(100, 80)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', 'A');
                        drawVector(o, scene.b, '#ff6b9d', 'B');
                        circ(o.x, o.y, 5, '#fff');
                        const ax = scene.a.x, ay = -scene.a.y, bx = scene.b.x, by = -scene.b.y, res = ax * bx + ay * by;
                        const fy = o.y + 78;
                        pill(`Step 1:  Ax √ó Bx = ${ax.toFixed(0)} √ó ${bx.toFixed(0)} = ${(ax * bx).toFixed(0)}`, o.x, fy, '#ffd166');
                        pill(`Step 2:  Ay √ó By = ${ay.toFixed(0)} √ó ${by.toFixed(0)} = ${(ay * by).toFixed(0)}`, o.x, fy + 26, '#ffd166');
                        pill(`Step 3:  Sum = ${(ax * bx).toFixed(0)} + ${(ay * by).toFixed(0)} = ${res.toFixed(0)}`, o.x, fy + 52, '#a8ff78');
                        pill(`A ¬∑ B = ${res.toFixed(0)}`, o.x, fy + 84, '#c77dff');
                    }
                },

                // 10
                {
                    title: 'Cosine Formula', chapter: 'Geometric Interpretation',
                    narrate: 'There is a geometric way to define the same dot product: A dot B equals the magnitude of A times the magnitude of B times cosine of the angle theta between them. This formula is equivalent to the component formula. It reveals why the dot product is so deeply connected to angles.',
                    desc: '<em>A ¬∑ B = ‚ÄñA‚Äñ √ó ‚ÄñB‚Äñ √ó cos(Œ∏)</em><br>Two definitions ‚Äî one product.',
                    enter() { setTgt('a', V(130, -50)); setTgt('b', V(100, 70)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', 'A');
                        drawVector(o, scene.b, '#ff6b9d', 'B');
                        drawAngleArc(o, scene.a, scene.b, 50);
                        circ(o.x, o.y, 5, '#fff');
                        const mA = mg(scene.a), mB = mg(scene.b), d = dot(scene.a, scene.b);
                        const cosT = d / (mA * mB), angDeg = r2d(Math.acos(clamp(cosT, -1, 1)));
                        const fy = o.y + 80;
                        pill(`‚ÄñA‚Äñ = ${mA.toFixed(0)},  ‚ÄñB‚Äñ = ${mB.toFixed(0)}`, o.x, fy, '#ffd166');
                        pill(`A ¬∑ B = ${d.toFixed(0)}  (component formula)`, o.x, fy + 26, '#a8ff78');
                        pill(`cos Œ∏ = dot / (‚ÄñA‚Äñ√ó‚ÄñB‚Äñ) = ${cosT.toFixed(3)}`, o.x, fy + 52, '#c77dff');
                        pill(`Œ∏ = ${angDeg.toFixed(1)}¬∞`, o.x, fy + 78, '#ffd166');
                    }
                },

                // 11
                {
                    title: 'Calculating the Angle', chapter: 'Geometric Interpretation',
                    narrate: 'Rearranging the cosine formula, we can solve for the actual angle. Divide the dot product by the product of the two magnitudes to get cosine theta, then apply arccosine to get theta in degrees or radians. This is how engines precisely measure the angle between any two directions.',
                    desc: 'Rearrange: <em>Œ∏ = arccos( A¬∑B / (‚ÄñA‚Äñ¬∑‚ÄñB‚Äñ) )</em>',
                    enter() { setTgt('a', V(120, -60)); setTgt('b', V(60, 110)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', 'A');
                        drawVector(o, scene.b, '#ff6b9d', 'B');
                        const d = dot(scene.a, scene.b), mA = mg(scene.a), mB = mg(scene.b);
                        const cosT = clamp(d / (mA * mB), -1, 1), ang = r2d(Math.acos(cosT));
                        drawAngleArc(o, scene.a, scene.b, 48, ang.toFixed(1) + '¬∞');
                        circ(o.x, o.y, 5, '#fff');
                        const fy = o.y + 80;
                        pill(`A ¬∑ B = ${d.toFixed(0)}`, o.x, fy, '#ffd166');
                        pill(`‚ÄñA‚Äñ √ó ‚ÄñB‚Äñ = ${mA.toFixed(0)} √ó ${mB.toFixed(0)} = ${(mA * mB).toFixed(0)}`, o.x, fy + 26, '#a8ff78');
                        pill(`cos Œ∏ = ${cosT.toFixed(3)}`, o.x, fy + 52, '#c77dff');
                        pill(`Œ∏ = arccos(${cosT.toFixed(3)}) = ${ang.toFixed(1)}¬∞`, o.x, fy + 78, '#ffd166');
                    }
                },

                // 12
                {
                    title: 'Reading the Sign', chapter: 'Geometric Interpretation',
                    narrate: 'Because cosine is positive for angles less than 90, zero at 90, and negative above 90, the sign of the dot product directly tells you the relationship between two directions. Positive means roughly aligned, zero means perpendicular, negative means facing away from each other.',
                    desc: '<em>Positive</em> = angle &lt;90¬∞ &nbsp; <em>Zero</em> = 90¬∞ &nbsp; <em>Negative</em> = angle &gt;90¬∞',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        const sp = Math.min(180, C.width / 3.4), yy = o.y - 20;
                        const o1 = V(o.x - sp, yy), o2 = V(o.x, yy), o3 = V(o.x + sp, yy);
                        drawVector(o1, V(70, -50), '#64ffda', '', false); drawVector(o1, V(80, -20), '#ff6b9d', '', false);
                        pill('dot > 0', o1.x, o1.y + 38, '#a8ff78'); pill('angle < 90¬∞', o1.x, o1.y + 60, '#5a6070', null, .8);
                        drawVector(o2, V(80, 0), '#64ffda', '', false); drawVector(o2, V(0, -80), '#ff6b9d', '', false);
                        drawRightAngle(o2, V(80, 0), V(0, -80), 13);
                        pill('dot = 0', o2.x, o2.y + 38, '#ffd166'); pill('exactly 90¬∞', o2.x, o2.y + 60, '#5a6070', null, .8);
                        drawVector(o3, V(70, -30), '#64ffda', '', false); drawVector(o3, V(-60, 50), '#ff6b9d', '', false);
                        pill('dot < 0', o3.x, o3.y + 38, '#ff6b9d'); pill('angle > 90¬∞', o3.x, o3.y + 60, '#5a6070', null, .8);
                    }
                },

                // 13
                {
                    title: 'Perpendicular Check', chapter: 'Geometric Interpretation',
                    narrate: 'One of the most powerful uses of the dot product is checking perpendicularity. Two vectors are perpendicular if and only if their dot product is zero. You skip all trigonometry and just check if a number is zero ‚Äî extremely fast in code, and used everywhere from physics to graphics.',
                    desc: '<em>A ¬∑ B = 0 ‚Üî perpendicular</em>. Fastest right-angle check in any engine.',
                    enter() { setTgt('a', V(140, 0)); setTgt('b', V(0, -120)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', 'A');
                        drawVector(o, scene.b, '#ff6b9d', 'B');
                        drawRightAngle(o, scene.a, scene.b, 14);
                        drawAngleArc(o, scene.a, scene.b, 32, '90¬∞');
                        circ(o.x, o.y, 5, '#fff');
                        const fy = o.y + 72;
                        pill('Ax√óBx = 140√ó0 = 0', o.x, fy, '#ffd166');
                        pill('Ay√óBy =   0√ó‚àí120 = 0', o.x, fy + 26, '#ffd166');
                        pill('dot = 0 + 0 = 0  ‚Üí  perpendicular ‚úì', o.x, fy + 52, '#a8ff78');
                    }
                },

                // 14
                {
                    title: 'Projection', chapter: 'Geometric Interpretation',
                    narrate: 'Projection is like casting a shadow. The scalar projection of A onto B tells you how far A extends in the direction of B. Compute it as the dot product of A with the unit vector of B. The vector projection is that scalar multiplied by the unit vector of B, giving you a new vector along B.',
                    desc: 'Scalar proj = <em>A ¬∑ √ª_B</em>. &nbsp; Vector proj = <em>(A ¬∑ √ª_B) √ó √ª_B</em>.',
                    enter() { setTgt('a', V(140, -80)); setTgt('b', V(180, 20)); },
                    draw(o) {
                        drawVector(o, scene.a, '#64ffda', 'A');
                        drawVector(o, scene.b, '#ff6b9d', 'B');
                        drawProjection(o, scene.a, scene.b);
                        drawAngleArc(o, scene.a, scene.b, 44);
                        const bh = hat(scene.b), proj = dot(scene.a, bh), pt = add(o, mul(bh, proj));
                        X.save(); X.strokeStyle = '#a8ff78'; X.lineWidth = 5; X.lineCap = 'round';
                        X.beginPath(); X.moveTo(o.x, o.y); X.lineTo(pt.x, pt.y); X.stroke(); X.restore();
                        pill('shadow of A on B', pt.x - 40, pt.y + 20, '#a8ff78');
                        pill('scalar = dot(A, √ª_B) = ' + proj.toFixed(0) + ' units', o.x, o.y + 100, '#ffd166');
                        circ(o.x, o.y, 5, '#fff');
                    }
                },

                // 15 ‚Äî app: lighting
                {
                    title: 'Application: Lighting', chapter: 'Applications',
                    narrate: 'In 3D rendering every surface has a normal vector pointing outward. The brightness equals the dot product of the surface normal with the direction toward the light. Positive means the surface faces the light and is bright. Zero or negative means it faces away and is dark or in shadow. Drag on the canvas to move the light.',
                    desc: '<em>Drag</em> the light! Brightness = dot(Normal, LightDir).',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); setTgt('light', V(80, -120)); },
                    onDrag(pos) {
                        const o = getOrigin();
                        const rel = sub(pos, V(o.x, o.y - 10));
                        if (mg(rel) > 10) setTgt('light', rel);
                    },
                    draw(o) {
                        const surfY = o.y + 55;
                        X.fillStyle = '#2a2a40'; X.fillRect(o.x - 120, surfY, 240, 10);
                        const N = V(0, -1), L = hat(scene.light), b = Math.max(0, dot(N, L));
                        const cv = Math.floor(b * 255);
                        const grd = X.createRadialGradient(o.x - 14, surfY - 52, 4, o.x, surfY - 44, 38);
                        grd.addColorStop(0, `rgb(${Math.min(255, cv + 70)},${Math.min(255, cv + 70)},${Math.min(255, cv + 70)})`);
                        grd.addColorStop(1, `rgb(${cv},${cv},${cv})`);
                        X.fillStyle = grd; X.beginPath(); X.arc(o.x, surfY - 44, 38, 0, Math.PI * 2); X.fill();
                        arrow(o.x, surfY, o.x, surfY - 80, '#a8ff78', 2.5, 10);
                        pill('Normal', o.x + 8, surfY - 86, '#a8ff78');
                        const lEnd = add(V(o.x, surfY - 44), mul(hat(scene.light), 85));
                        arrow(o.x, surfY - 44, lEnd.x, lEnd.y, '#ffd166', 2.5, 12);
                        pill('Light ‚Üê drag!', lEnd.x + (lEnd.x > o.x ? 10 : -10), lEnd.y - 14, '#ffd166');
                        pill(`dot(N,L) = ${b.toFixed(2)}   Brightness = ${(b * 100).toFixed(0)}%`, o.x, o.y + 118, b > 0.4 ? '#fff' : '#556');
                    }
                },

                // 16 ‚Äî app: FOV
                {
                    title: 'Application: Field of View', chapter: 'Applications',
                    narrate: 'Game AI uses the dot product to check if the player can see an enemy. Compute the dot product of the look direction with the unit vector toward the enemy. If it exceeds the cosine of half the field-of-view angle, the enemy is inside the cone and visible. Drag on the canvas to move the enemy.',
                    desc: '<em>Drag</em> the enemy! dot(look, toEnemy) > cos(FOV√∑2) ‚Üí visible.',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); setTgt('enemy', V(100, 50)); setTgt('look', V(100, 0)); },
                    onDrag(pos) {
                        const o = getOrigin();
                        setTgt('enemy', sub(pos, o));
                    },
                    draw(o) {
                        const lookDir = hat(scene.look), ePos = add(o, scene.enemy), toE = hat(sub(ePos, o));
                        const fovH = Math.PI / 3, cosT = Math.cos(fovH), dv = dot(lookDir, toE), vis = dv > cosT;
                        const baseAng = Math.atan2(lookDir.y, lookDir.x);
                        X.save(); X.fillStyle = 'rgba(100,255,218,.06)';
                        X.beginPath(); X.moveTo(o.x, o.y); X.arc(o.x, o.y, 140, baseAng - fovH, baseAng + fovH); X.closePath(); X.fill();
                        X.strokeStyle = 'rgba(100,255,218,.18)'; X.lineWidth = 1; X.setLineDash([4, 4]);
                        X.beginPath(); X.moveTo(o.x, o.y); X.arc(o.x, o.y, 140, baseAng - fovH, baseAng + fovH); X.closePath(); X.stroke();
                        X.setLineDash([]); X.restore();
                        circ(o.x, o.y, 10, '#64ffda');
                        arrow(o.x, o.y, o.x + lookDir.x * 60, o.y + lookDir.y * 60, '#64ffda', 3, 10);
                        pill('Player', o.x + lookDir.x * 75, o.y + lookDir.y * 75, '#64ffda');
                        X.save(); X.setLineDash([5, 5]); X.strokeStyle = '#333';
                        X.beginPath(); X.moveTo(o.x, o.y); X.lineTo(ePos.x, ePos.y); X.stroke(); X.restore();
                        circ(ePos.x, ePos.y, 10, vis ? '#ff6b9d' : '#556');
                        pill('Enemy ‚Üê drag!', ePos.x, ePos.y - 22, vis ? '#ff6b9d' : '#556');
                        pill((vis ? '‚úì VISIBLE   ' : ' ‚úó NOT VISIBLE   ') + `dot=${dv.toFixed(2)} threshold=${cosT.toFixed(2)}`, o.x, o.y + 130, vis ? '#a8ff78' : '#ff4d6d');
                    }
                },

                // 17 ‚Äî app: AI steering
                {
                    title: 'Application: AI Steering', chapter: 'Applications',
                    narrate: 'In game AI we often need to turn a character toward a target. The dot product of the forward vector with the vector to the target tells us how aligned the character is. The dot product of the right vector with the vector to the target tells us which side the target is on ‚Äî positive means turn right, negative means turn left. Drag the target to explore.',
                    desc: 'dot(fwd, toTarget) = alignment. dot(right, toTarget) ‚Üí <em>which side to turn</em>. Drag!',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); setTgt('enemy', V(80, -60)); setTgt('look', V(100, 0)); },
                    onDrag(pos) {
                        const o = getOrigin();
                        setTgt('enemy', sub(pos, o));
                    },
                    draw(o) {
                        const fwd = hat(scene.look), right = V(-fwd.y, fwd.x), target = add(o, scene.enemy);
                        const toT = hat(sub(target, o)), fwdD = dot(fwd, toT), rightD = dot(right, toT);
                        circ(o.x, o.y, 12, '#64ffda');
                        arrow(o.x, o.y, o.x + fwd.x * 55, o.y + fwd.y * 55, '#64ffda', 3, 12); pill('fwd', o.x + fwd.x * 70, o.y + fwd.y * 70, '#64ffda');
                        arrow(o.x, o.y, o.x + right.x * 40, o.y + right.y * 40, '#4499ff', 2, 10); pill('right', o.x + right.x * 56, o.y + right.y * 56, '#4499ff');
                        circ(target.x, target.y, 10, '#ffd166');
                        pill('Target ‚Üê drag!', target.x, target.y - 22, '#ffd166');
                        arrow(o.x, o.y, target.x, target.y, 'rgba(255,209,102,.35)', 1.5, 12);
                        const turnDir = rightD > 0 ? '‚Üí Turn RIGHT' : '‚Üê Turn LEFT';
                        pill(`dot(fwd, toTarget)   = ${fwdD.toFixed(2)}  ‚Äî ${fwdD > 0.95 ? 'Aligned!' : fwdD > 0 ? 'Partially facing' : 'Facing away'}`, o.x, o.y + 100, '#ffd166');
                        pill(`dot(right, toTarget) = ${rightD.toFixed(2)}  ‚Äî ${turnDir}`, o.x, o.y + 126, '#4499ff');
                    }
                },

                // 18 ‚Äî app: camera look-at
                {
                    title: 'Application: Camera Look-At', chapter: 'Applications',
                    narrate: 'Every 3D camera needs a look direction. Given the camera position and a target, the look direction is simply the normalized vector from camera to target. We also dot the look direction with the world up vector to detect if the camera is about to flip upside down. Drag the target.',
                    desc: 'Camera direction = <em>normalize(target ‚àí cam)</em>. dot(dir, worldUp) detects flip. Drag!',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); setTgt('camTarget', V(100, -60)); },
                    onDrag(pos) {
                        const o = getOrigin();
                        setTgt('camTarget', sub(pos, o));
                    },
                    draw(o) {
                        const cam = V(o.x - 70, o.y + 40), target = add(o, scene.camTarget);
                        const lookDir = hat(sub(target, cam)), worldUp = V(0, -1), dotUp = dot(lookDir, worldUp);
                        const flipped = dotUp < -0.9;
                        arrow(o.x - 130, o.y + 70, o.x - 130, o.y - 20, '#3a3a5c', 2, 8); pill('world up', o.x - 130, o.y - 30, '#3a3a5c');
                        X.fillStyle = '#1a1a40'; X.beginPath(); X.roundRect(cam.x - 16, cam.y - 11, 32, 22, 4); X.fill();
                        X.strokeStyle = '#64ffda'; X.lineWidth = 2; X.beginPath(); X.roundRect(cam.x - 16, cam.y - 11, 32, 22, 4); X.stroke();
                        pill('CAM', cam.x, cam.y + 2, '#64ffda');
                        circ(target.x, target.y, 8, '#ffd166');
                        pill('Target ‚Üê drag!', target.x, target.y - 22, '#ffd166');
                        arrow(cam.x, cam.y, cam.x + lookDir.x * 80, cam.y + lookDir.y * 80, '#a8ff78', 2.5, 12);
                        pill('lookDir', cam.x + lookDir.x * 96, cam.y + lookDir.y * 96, '#a8ff78');
                        pill(`dot(lookDir, worldUp) = ${dotUp.toFixed(2)}  ${flipped ? '‚ö† CAMERA FLIPPED!' : '‚úì OK'}`, o.x, o.y + 108, flipped ? '#ff4d6d' : '#a8ff78');
                    }
                },

                // 19 ‚Äî app: closest point
                {
                    title: 'Application: Closest Point on Line', chapter: 'Applications',
                    narrate: 'To find the closest point on a line segment to a point P, we project P onto the line using the dot product, then clamp the parameter t to the range 0 to 1. This is used everywhere: collision detection, rope physics, pathfinding, and more. Drag the target point.',
                    desc: '<em>t = dot(P‚àíA, B‚àíA) / ‚ÄñB‚àíA‚Äñ¬≤</em>, clamp to [0,1]. Drag!',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); setTgt('pt', V(80, -80)); },
                    onDrag(pos) {
                        const o = getOrigin();
                        setTgt('pt', sub(pos, o));
                    },
                    draw(o) {
                        const p1 = V(-140, 60), p2 = V(140, -60), pt = scene.pt;
                        X.beginPath(); X.moveTo(o.x + p1.x, o.y + p1.y); X.lineTo(o.x + p2.x, o.y + p2.y);
                        X.strokeStyle = '#555'; X.lineWidth = 4; X.lineCap = 'round'; X.stroke();
                        circ(o.x + p1.x, o.y + p1.y, 4, '#555'); circ(o.x + p2.x, o.y + p2.y, 4, '#555');
                        pill('P1', o.x + p1.x - 16, o.y + p1.y + 16, '#5a6070'); pill('P2', o.x + p2.x + 16, o.y + p2.y - 14, '#5a6070');
                        const line = sub(p2, p1), len2 = dot(line, line), toPt = sub(pt, p1);
                        const t = clamp(dot(toPt, line) / len2, 0, 1), closest = add(p1, mul(line, t));
                        X.save(); X.setLineDash([4, 4]); X.strokeStyle = '#ffd166';
                        X.beginPath(); X.moveTo(o.x + pt.x, o.y + pt.y); X.lineTo(o.x + closest.x, o.y + closest.y); X.stroke(); X.restore();
                        circ(o.x + pt.x, o.y + pt.y, 8, '#ff6b9d');
                        pill('Target ‚Üê drag!', o.x + pt.x, o.y + pt.y - 20, '#ff6b9d');
                        circ(o.x + closest.x, o.y + closest.y, 7, '#a8ff78');
                        pill('Closest', o.x + closest.x, o.y + closest.y + 20, '#a8ff78');
                        pill(`t = ${t.toFixed(2)}  (0 = P1, 1 = P2, clamped)`, o.x, o.y + 108, '#ffd166');
                    }
                },


                // 21 ‚Äî advanced: dot product in 3D
                {
                    title: 'Dot Product in 3D', chapter: 'Advanced Topics',
                    narrate: 'Everything generalises perfectly to three dimensions. A 3D vector has X, Y, and Z components. The dot product formula extends by adding the Z terms: Ax times Bx plus Ay times By plus Az times Bz. The same cosine formula applies, the same sign rules apply. This is used constantly in 3D graphics, physics engines, and neural networks.',
                    desc: '3D: <em>A¬∑B = Ax¬∑Bx + Ay¬∑By + Az¬∑Bz</em>. Same cosine formula, same rules.',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        const ox = o.x - 70, oy = o.y + 20, sc = 80;
                        arrow(ox, oy, ox + sc, oy - sc * .4, '#4477ff', 2, 10); pill('X', ox + sc + 8, oy - sc * .4, '#4477ff');
                        arrow(ox, oy, ox + sc * .55, oy + sc * .6, '#44aa44', 2, 10); pill('Y', ox + sc * .55 + 8, oy + sc * .6 + 4, '#44aa44');
                        arrow(ox, oy, ox - sc * .4, oy - sc * .5, '#ff4444', 2, 10); pill('Z', ox - sc * .4 - 8, oy - sc * .5, '#ff4444');
                        const a3ox = o.x + 70, a3oy = o.y;
                        const aEnd = V(a3ox + 100, a3oy - 50), bEnd = V(a3ox + 70, a3oy + 70);
                        arrow(a3ox, a3oy, aEnd.x, aEnd.y, '#64ffda', 3, 16); pill('A=(2,3,1)', aEnd.x + 10, aEnd.y - 14, '#64ffda');
                        arrow(a3ox, a3oy, bEnd.x, bEnd.y, '#ff6b9d', 3, 16); pill('B=(1,2,4)', bEnd.x + 10, bEnd.y + 10, '#ff6b9d');
                        circ(a3ox, a3oy, 5, '#fff');
                        const fy = o.y + 88;
                        pill('A¬∑B = (2√ó1) + (3√ó2) + (1√ó4)', o.x, fy, '#ffd166');
                        pill('    =   2   +   6   +  4  = 12', o.x, fy + 26, '#a8ff78');
                    }
                },

                // 23 ‚Äî advanced: slope detection
                {
                    title: 'Application: Slope Detection', chapter: 'Advanced Topics',
                    narrate: 'When a character walks on terrain, we need to know if a slope is too steep to climb. The surface normal of flat ground points straight up. Dot it with the world up vector. If the result is close to 1 the surface is flat. If it falls below a threshold ‚Äî typically around 0.7 ‚Äî the slope is too steep and the character should slide.',
                    desc: 'dot(surfNormal, worldUp) ‚Üí 1 = flat, 0 = vertical wall. Use threshold ~0.7.',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        const cy = o.y + 20;
                        const segs = [{ a: 5, lbl: '5¬∞  flat ‚Äî walkable', col: '#a8ff78' }, { a: 38, lbl: '38¬∞ steep ‚Äî marginal', col: '#ffd166' }, { a: 72, lbl: '72¬∞ cliff ‚Äî too steep', col: '#ff6b9d' }];
                        segs.forEach((s, i) => {
                            const sx = o.x + (i - 1) * 165, ar = d2r(s.a), len = 78, dx = Math.cos(ar) * len, dy = Math.sin(ar) * len;
                            X.strokeStyle = s.col; X.lineWidth = 4; X.lineCap = 'round';
                            X.beginPath(); X.moveTo(sx - dx / 2, cy + dy / 2); X.lineTo(sx + dx / 2, cy - dy / 2); X.stroke();
                            const nx = -Math.sin(ar), ny = -Math.cos(ar);
                            arrow(sx, cy, sx + nx * 44, cy + ny * 44, s.col, 2.5, 8);
                            pill('N', sx + nx * 56, cy + ny * 56, s.col);
                            pill(`dot = ${Math.cos(ar).toFixed(2)}`, sx, cy + 58, s.col);
                            pill(s.lbl, sx, cy + 80, s.col);
                        });
                        pill('dot(N, worldUp) threshold ‚âà 0.7', o.x, cy + 104, '#5a6070');
                    }
                },


                // 26 ‚Äî summary
                {
                    title: 'Summary', chapter: 'Advanced Topics',
                    narrate: 'You have completed the full dot product tutorial. You now know what vectors are, how to compute the dot product, what the cosine formula means geometrically, how to extract angles and projections, and how these ideas power physics.',
                    desc: 'Complete! Vectors + dot product = the foundation ofphysics',
                    enter() { setTgt('a', V(0, 0)); setTgt('b', V(0, 0)); },
                    draw(o) {
                        pill('Tutorial Complete  ‚úì', o.x, o.y - 148, '#64ffda', null, 1);
                        const cols = ['#64ffda', '#ffd166', '#a8ff78', '#c77dff', '#ff6b9d', '#4499ff'];
                        const items = [
                            'Vectors: direction + magnitude (2D & 3D)',
                            'Components, notation, scalar multiplication',
                            'Addition (tip-to-tail) & subtraction',
                            'Magnitude, unit vectors, normalization',
                            'Dot product: A¬∑B = Œ£(Ai¬∑Bi)',
                            'Cosine formula: A¬∑B = ‚ÄñA‚Äñ‚ÄñB‚ÄñcosŒ∏',
                            'Sign: aligned / perpendicular / opposite',
                            'Projection: shadow on a direction',
                            'Closest Point, Reflection, Culling, Slope',
                        ];
                        items.forEach((it, i) => pill('‚úì  ' + it, o.x, o.y - 112 + i * 24, cols[i % cols.length], 'rgba(0,0,0,0)', 1));
                    }
                }

            ];
        } // buildTutorial
        buildTutorial();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  HELPERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function getChapter(idx) {
            let ch = '';
            for (const [k, v] of Object.entries(CHAPTERS)) if (idx >= parseInt(k)) ch = v;
            return ch;
        }
        function updateUI() {
            const s = tutSteps[tutCur];
            document.getElementById('sNum').textContent = `Step ${tutCur + 1} of ${tutSteps.length}`;
            document.getElementById('sTitle').textContent = s.title;
            document.getElementById('sDesc').innerHTML = s.narrate || s.desc;
            document.getElementById('mBox').textContent = s.math || '';
            document.getElementById('pFill').style.width = `${((tutCur + 1) / tutSteps.length) * 100}%`;
            document.getElementById('pL').textContent = `Step ${tutCur + 1}`;
            document.getElementById('pR').textContent = `of ${tutSteps.length}`;
            document.getElementById('chapterLbl').textContent = getChapter(tutCur);
            document.getElementById('btnPrev').disabled = tutCur === 0;
            document.getElementById('btnNext').disabled = tutCur === tutSteps.length - 1;
        }
        function renderScene() {
            bg();
            const s = tutSteps[tutCur];
            if (s && s.draw) { const o = getOrigin(); s.draw({ x: o.x, y: o.y }); }
        }
        function goTo(idx) {
            tutCur = clamp(idx, 0, tutSteps.length - 1);
            const s = tutSteps[tutCur];
            if (s.enter) s.enter();
            updateUI();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  MAIN LOOP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function loop() { updateScene(); renderScene(); requestAnimationFrame(loop); }
        loop();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  POINTER INPUT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let dragging = false;
        C.addEventListener('pointerdown', e => { dragging = true; C.setPointerCapture(e.pointerId); });
        window.addEventListener('pointerup', () => { dragging = false; });
        C.addEventListener('pointermove', e => {
            if (!dragging) return;
            const s = tutSteps[tutCur];
            if (s && s.onDrag) { const r = C.getBoundingClientRect(); s.onDrag(V(e.clientX - r.left, e.clientY - r.top)); }
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  TTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let synth = window.speechSynthesis, voices = [];
        const muteBtn = document.getElementById('btnMute'), voiceSel = document.getElementById('ttsVoice');
        let muted = false, autoPlay = false, autoTimer = null;

        function loadVoices() {
            voices = synth.getVoices();
            voiceSel.innerHTML = '<option value="">Default voice</option>';
            voices.forEach((v, i) => { const opt = document.createElement('option'); opt.value = i; opt.textContent = `${v.name} (${v.lang})`; voiceSel.appendChild(opt); });
            const pref = ['Microsoft Aria', 'Microsoft Jenny', 'Google US English', 'Samantha', 'Daniel'];
            for (const n of pref) { const idx = voices.findIndex(v => v.name.includes(n)); if (idx !== -1) { voiceSel.value = idx; break; } }
        }
        if (synth && synth.onvoiceschanged !== undefined) synth.onvoiceschanged = loadVoices;
        loadVoices();

        function stopAuto() {
            autoPlay = false; clearTimeout(autoTimer);
            document.getElementById('btnAuto').textContent = '‚ñ∂ Auto';
            document.getElementById('btnAuto').classList.remove('primary');
            if (synth) synth.cancel();
        }

        function speakStep() {
            if (autoTimer) clearTimeout(autoTimer);
            if (!synth) return;
            synth.cancel();
            const s = tutSteps[tutCur];
            if (muted || !s.narrate) {
                if (autoPlay) { const dur = Math.max(2500, (s.narrate || '').split(' ').length / 200 * 60000); autoTimer = setTimeout(nextStep, dur); }
                return;
            }
            const u = new SpeechSynthesisUtterance(s.narrate);
            if (voiceSel.value !== '') u.voice = voices[parseInt(voiceSel.value)];
            u.rate = 1.0;
            // Duck background music while speaking
            if (window.bgMusicDuck) window.bgMusicDuck();
            u.onend = () => { if (window.bgMusicRestore) window.bgMusicRestore(); if (autoPlay) autoTimer = setTimeout(nextStep, 2200); };
            u.onerror = () => { if (window.bgMusicRestore) window.bgMusicRestore(); };
            synth.speak(u);
        }

        function nextStep() {
            if (tutCur < tutSteps.length - 1) { goTo(tutCur + 1); speakStep(); }
            else stopAuto();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  BUTTONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        document.getElementById('btnNext').addEventListener('click', () => {
            if (window.startBgMusic) window.startBgMusic();
            stopAuto(); nextStep();
        });
        document.getElementById('btnPrev').addEventListener('click', () => { stopAuto(); if (tutCur > 0) { goTo(tutCur - 1); speakStep(); } });
        document.getElementById('btnReset').addEventListener('click', () => { stopAuto(); goTo(0); if (synth) synth.cancel(); });
        document.getElementById('btnAuto').addEventListener('click', () => {
            if (window.startBgMusic) window.startBgMusic();
            autoPlay = !autoPlay;
            const btn = document.getElementById('btnAuto');
            if (autoPlay) { btn.textContent = '‚èπ Stop'; btn.classList.add('primary'); if (!synth.speaking) speakStep(); }
            else stopAuto();
        });
        muteBtn.addEventListener('click', () => {
            muted = !muted; muteBtn.textContent = muted ? 'üîá' : 'üîä';
            if (muted && synth) synth.cancel(); else speakStep();
        });

        // Music button ‚Äî hooks into bg-music.js globals
        document.getElementById('btnMuteMusic').addEventListener('click', () => {
            if (window.toggleBgMusicMute) {
                const isMuted = window.toggleBgMusicMute();
                document.getElementById('btnMuteMusic').style.opacity = isMuted ? '0.4' : '1';
            }
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  INIT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        goTo(0);
    </script>

    <!-- Background music (loaded from local environment) -->
    <script src="bg-music.js"></script>
</body>

</html>